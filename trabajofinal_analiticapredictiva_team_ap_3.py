# -*- coding: utf-8 -*-
"""TrabajoFinal-AnaliticaPredictiva-TEAM-AP-3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bn0DxXYbfTa_dPfaElnqjLSLRIB5ryiD

# Introducción

**TRABAJO FINAL ANALITICA PREDICTIVA: Pronóstico de la evolución de casos activos de SARS-CoV-2 en Colombia**

**Grupo: AP-2020-1S/covid-19-team-ap-3**

**INTEGRANTES:**

> Leidy Johanna Isaza Ruiz
>
>Juan David Betancur Piedrahita
>
>Santiago Herrera Morales
>
>Eyder Daniel Restrepo Nunez

##Objetivo

El objetivo de este proyecto es la predicción de corto y mediano plazo de el total de casos confirmados, los nuevos casos, los casos activos, recuperados y muertes para las 5 principales ciudades de Colombia: **Bogotá, Medellín, Cali, Cartagena y Barranquilla**, utilizando técnicas estadísticas, de inteligencia artificial o modelos híbridos. El proyecto se trabajó con la metodoliga CRISP-DM

###1. Definión del problema real


Determinar la cantidad de personas infectadas por COVID-19, con el objetivo de determinar los riesgos de capacidades de atención, las médidas y restricciones necesarias tomadas por el gobierno para evitar el colapso del sistema de salud y el desbordamiento de la propagación del virus, elevando la tasa de mortalidad frente el virus.

###2. Definición del problema de análitica

Conectar la fuente de información dispuesta por el gobierno nacional, limpiar los datos, adición de datos complementarios de la población por ciudad. Determinar los modelos que se usaran para pronósticar el comportamiento del fenómeno que se desea estudiar, seguido de esto se debe determinar las variables de entrada que permitan ejecución de estos.

Con los resultados de la modelación es necesario determinar la acertividad de los pronóstico arrojados por los modelos y finalmente, se realizan proceso de optimización buscando la mejora de la exactitud ajustando algunos de los atributos del modelo. Con el fin de poder determinar los infectados, recuperados, fallecidos y la población suceptible.

El presenté proyecto se acotó a las cinco ciudades principales de Colombia, bajo el críterio de tamaño de la población. Enfocando en Bogotá DC, Medellín, Cali, Cartagena de Indias y Barranquilla.

#3. Datos

Para el desarrollo de este proyecto se utilizaron dos fuentes de información: las tablas operativas relacionadas a la pandemia del COVID-19 para Colombia, suministradas por el gobierno nacional a través de la API (www.datos.gov.co). Por otra parte, a través consultamos el portal del Dane para extraer información de la población por ciudad.

**Figura 1:** Presentamos a continuación los metadatos de la información de registros del COVID 19 a nivel nacional

![Metadatos.png](data:image/png;base64,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)

**Figura 2:** Presentamos a continuación los metadatos de la información de población por ciudad del Dane.

![metadatos Dane.png](data:image/png;base64,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)

# Conexión de los Datos
La siguiente rutina permite descargar los datos publicados diariamente por el gobierno nacional. Buscando la comprensión y entendimiento de los datos, desde la colección de estos, identificando así los problemas de calidad, hipótesis preliminares e información oculta, todo esto será tratado a profundidad en las fases siguientes.
"""

#Instalación de sodapy necesario para la conexión con datos.gov.co
!pip install sodapy

#Importación de liberarias necesarias para el proyecto
import pandas as pd
import numpy as np
import datetime
import statistics as stats
from pandas import DataFrame
from datetime import date
from datetime import datetime
from datetime import timedelta
from scipy.integrate import odeint 
from scipy.optimize import curve_fit
from scipy.optimize import fsolve
from scipy import stats as stat
import cufflinks as cf
import plotly.offline as py
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(rc={'figure.figsize':(35, 12)})
from sklearn.metrics import mean_squared_error
import io
import requests

plt.rc('figure', figsize=(35, 12))

#Creación de una carpeta para guardar el contenido del proyecto
!mkdir /content/figs/

#Importar la información
from sodapy import Socrata

# Authenticated client (needed for non-public datasets):
client = Socrata("www.datos.gov.co",
                  "8Re11GXR1ar0hvLXTeZmZAzY0",
                  username="sherreramo@unal.edu.co",
                  password="Herrera123@")

results = client.get("gt2j-8ykr", limit=2000000)

#Convert to pandas DataFrame
results_df = pd.DataFrame.from_records(results)

#Dataframe descargado de Datos.gov.co
results_df

"""Carga información DANE, debido a que no fue posible realizar una conexión a través de la API, fue necesario descargar un archivo en formato .csv, el cual fue cargado en GitHub. En términos prácticos la población por ciudad tienda a ser un dato con baja variabilidad en el corto plazo. Por está razón se tomó la determinación de cargarlo.

> Repo personal - archivo completo
"""

#Conexión archivo .csv desde cuenta de Github.com
poblacion = pd.read_excel("https://github.com/sherreramo/sherreramo.github.io/blob/master/anexos-proyecciones-poblacion-area-sexo-2018-2023.xls?raw=true", sheet_name='Municipios', skiprows=7, converters={'COD_MPIO': lambda x: str(x)})

#Se presenta información completa y original del DANE
poblacion2 = poblacion[poblacion.COD_MPIO.notna()]
poblacion2

#Se filtran las 5 ciudades selecionadas a través de su código de municipio.
poblacion2 = poblacion[poblacion.COD_MPIO.notna()]

poblacion3 = poblacion2[poblacion2.COD_MPIO.isin(['11001', '05001', '76001','13001','08001'])]

poblacion4 = poblacion3[['COD_DPTO', 'NOMBRE DPTO', 'COD_MPIO', 'NOMBRE MPIO', 'SEXOS', 2018, 2019, 2020, 2021, 2022, 2023]]
poblacion4

#Se presenta resumen de población por ciudad
poblacion5 = poblacion4[poblacion2.SEXOS.isin(['AMBOS SEXOS'])]
poblacion6 = poblacion5[['COD_DPTO', 'NOMBRE DPTO', 'COD_MPIO', 'NOMBRE MPIO', 'SEXOS', 2020]]
poblacion6.columns = ['COD_DPTO', 'NOMBRE DPTO', 'c_digo_divipola', 'NOMBRE_MPIO', 'SEXOS', 'poblacion']
poblacion7 = poblacion6[['c_digo_divipola', 'poblacion', 'NOMBRE_MPIO']]
poblacion7

"""#Limpieza

El proceso de limpieza o preparación de los datos cubre todas las actividades necesarias para construir el conjunto de datos necesarios para utilizar las herramientas de modelado. A partir de los datos en bruto iniciales capturados desde las fuentes de datos.gov.co y DANE.gov.co. A continuación se presenta la rutina de selección de tablas, registros y atributos, transformación y limpieza de datos.
"""

#Se realiza una copia del dataframe para evitar generar daños en la tabla original e iniciar así los ajustes.
results_df2 = results_df.copy()

#Se presenta el dataframe
results_df2

#En las visualizaciones preliminares, notamos la aparición de NA en los datos. Por esto optamos por reemplazar dichos NA en fecha diagnóstico por 'A'
results_df2['fecha_diagnostico'].replace(
    to_replace=np.nan,
    value="A",
    inplace=True
)

#Para evitar la perdida de estos datos con NA en la decha de diagnóstico, determinamos asignar la fecha de FIS (fecha de inicio de síntomas), cómo fecha de diagnóstico. Pues es preferible distorcionar levemente la información que perder un volumen considerable de datos. Definición de función para reemplazar los 'A' en fecha diagnóstico por el valor en FIS
def generar_ax_fecha_diag(row):
    #result = 5 #row['fecha_diagnostico']
    if str(row["fecha_diagnostico"]) == 'A':
      result = str(row["fis"])
    else:
      result = str(row["fecha_diagnostico"])
    return result

#Por otra parte, para los asintomáticos naturalmente no tienen fecha de diagnóstico, por está razón asignamos la fecha de notificación. Definición de función para reemplazar los 'Asintomático' en fecha diagnóstico por el valor en 'fecha_de_notificaci_n'
def correc_ax_fecha_diag(row):
    #result = 5 #row['fecha_diagnostico']
    if str(row["ax_fecha_diagnostico"]) == 'Asintomático':
      result = str(row["fecha_de_notificaci_n"])
    else:
      result = str(row["ax_fecha_diagnostico"])
    return result

#Generar fecha auxiliar de diagnóstico
results_df2["ax_fecha_diagnostico"] = results_df2.apply(generar_ax_fecha_diag, axis=1)

#Corregir fecha auxiliar de diagnóstico
results_df2["ax_fecha_diagnostico"] = results_df2.apply(correc_ax_fecha_diag, axis=1)

#Generar fecha de inicio de sintomas auxiliar 
results_df2['ax_fis_2']= results_df2['fis']

#Todos los asintomáticos los reemplazamos por la fecha 2020-12-31 para evitar errores al computar el campo
results_df2['ax_fis_2'].replace(
    to_replace= "Asintomático",
    value="2020-12-31T00:00:00.000",
    inplace=True
)

#Cambio de formato de las fechas
results_df2['fecha_de_notificaci_n'] = pd.to_datetime(results_df2.fecha_de_notificaci_n)
results_df2['fecha_recuperado'] = pd.to_datetime(results_df2.fecha_recuperado)
results_df2['fecha_reporte_web'] = pd.to_datetime(results_df2.fecha_reporte_web)
results_df2['fecha_de_muerte'] = pd.to_datetime(results_df2.fecha_de_muerte)
results_df2['ax_fecha_diagnostico'] = pd.to_datetime(results_df2.ax_fecha_diagnostico)
results_df2['ax_fis_2'] = pd.to_datetime(results_df2.ax_fis_2)

#Extracción solo Fecha de Fis
results_df2['ax_fis_2'] = results_df2.ax_fis_2.map(lambda x: x.strftime('%Y-%m-%d'))

#Correción de tipo de campo "datatime" para FIS 2
results_df2['ax_fis_2'] = pd.to_datetime(results_df2.ax_fis_2)

#Definición de función para determinar el día inicial
def generar_ax_fecha_inicio(row):
    if row["ax_fecha_diagnostico"] > row["ax_fis_2"]:
      result = row["ax_fis_2"]
    else:
      result = row["ax_fecha_diagnostico"]
    return result

#Generar fecha auxiliar de inicio
results_df2["ax_fecha_inicio"] = results_df2.apply(generar_ax_fecha_inicio, axis=1)

#Correción de tipo de campo para Fecha inicio
results_df2['ax_fecha_inicio'] = pd.to_datetime(results_df2.ax_fecha_inicio)

#Cálculo días hasta la recuperación
#Cálculo días hasta la Muerte
results_df2['ax_dias_recuperacion'] = (results_df2['fecha_recuperado']) - (results_df2['ax_fecha_inicio'])
results_df2['ax_dias_muerte'] = (results_df2['fecha_de_muerte']) - (results_df2['ax_fecha_inicio'])

#Volver números los días de recuperación
def correc_ax_dias_recup(row):
    x = (row["ax_dias_recuperacion"]).days
    if x >= 0:
      return x
    elif x < 0:
      return x
    else:
      return None

#Volver números los días de muerte
def correc_ax_dias_muerte(row):

    x = (row["ax_dias_muerte"]).days
    if x >= 0:
      return x
    elif x < 0:
      return x
    else:
      return None

#Generar los campos númericos de días entre diagnóstico, muerte y recuperación
results_df2['ax_dias_recuperacion2'] = results_df2.apply(correc_ax_dias_recup, axis=1)
results_df2['ax_dias_muerte2'] = results_df2.apply(correc_ax_dias_muerte, axis=1)

#Para el cálculo de la media, generamos dos df solo con los casos con información, 
#quitando los asintomáticos para el calculo de la recuperación
##Recuperados no asintomáticos

results_df3 = results_df2[results_df2.atenci_n== 'Recuperado']
results_df3 = results_df3[results_df3.fis != 'Asintomático']
results_df4 = results_df2[results_df2.estado == 'Fallecido']

#Media de recuperación y muerte para los casos con información en los respectivos casos
media_recuperacion = stats.mean(results_df3.ax_dias_recuperacion2)
media_muerte = stats.mean(results_df4.ax_dias_muerte2)

"""Considerando los datos a nivel nacional, una persona infectada tarda en promedio para recuperarse:"""

print('Media de Recuperación:', int(media_recuperacion), "días")

"""Por otra parte, una persona infectada que muere tarda en promedio:"""

print('Media de Muerte:', int(media_muerte), 'días')

#Considerando un alto volumen de datos de recuperados mayores a 30 días que podrían generar ruido en el análisis. Se determinó excluir los registros con días de recuperación mayor a 30
results_df7 = results_df3[results_df3.ax_dias_recuperacion2 <= 30]
len(results_df7)

#Excluyendo días de recuperación mayor a 30
#Media de recuperación y muerte para los casos con información en los respectivos casos
media_recuperacion = stats.mean(results_df7.ax_dias_recuperacion2)
print('Media de recuperación:')
print(int(media_recuperacion), "días")
#media_muerte = stats.mean(results_df4.ax_dias_muerte2)
#print(media_muerte)
#Mediana de recuperación y muerte para los casos con información en los respectivos casos
mediana_recuperacion = stats.median(results_df7.ax_dias_recuperacion2)
print('Mediana de recuperación:')
print(int(mediana_recuperacion), "días")
#mediana_muerte = stats.median(results_df4.ax_dias_muerte2)
#print(media_muerte)
moda_recuperacion = stats.mode(results_df7.ax_dias_recuperacion2)
print('Moda de recuperación:')
print(int(moda_recuperacion), "días")

#Mediana de recuperación y muerte para los casos con información en los respectivos casos
mediana_recuperacion = stats.median(results_df3.ax_dias_recuperacion2)
print('Media de recuperación: ', int(media_recuperacion), "días")
mediana_muerte = stats.median(results_df4.ax_dias_muerte2)
print('Media de muerte:', int(media_muerte), 'días')

#Tasa de fallecidos general sin excluir nada

tasa_fallecidos = (len(results_df4)/len(results_df2))
porcentaje_fallecidos = "{:.2%}".format((len(results_df4)/len(results_df2))*1)
print('Tasa de fallecidos:', round(tasa_fallecidos*100,2),'%')

#Calculo de los casos por calsificación: general, fellecidos, recuperados y activos
casos_general = len(results_df2)
casos_muertos_df = results_df2[results_df2.estado == 'Fallecido']
casos_muertos = len(casos_muertos_df)
casos_recuperados_df = results_df2[results_df2.atenci_n == 'Recuperado']
casos_recuperados = len(casos_recuperados_df)
casos_activos = casos_general - casos_muertos - casos_recuperados

print("Casos General: {:,}".format(casos_general))
print("Casos Activos: {:,}".format(casos_activos))
print("Casos Fallecidos: {:,}".format(casos_muertos))
print("Casos Recuperados: {:,}".format(casos_recuperados))
print("Casos Recuperados no asintomáticos: {:,}".format(len(results_df3)))
#print(casos_muertos)
#print(casos_recuperados)

#Información nuevos contagios por ciudad para cada uno de los dias
df_contagios_1 = results_df2[['fecha_reporte_web', 'c_digo_divipola']]
df_contagios_1.columns = ['fecha', 'c_digo_divipola']
df_contagios_1['nuevos_contagios'] = 1
df_contagios_1

#Inofmración nuevos fallecidos
df_fallecidos_1 = results_df2[['fecha_de_muerte', 'c_digo_divipola', 'atenci_n', 'ax_dias_muerte2']]
df_fallecidos_2 = df_fallecidos_1[df_fallecidos_1.atenci_n == 'Fallecido']
df_fallecidos_3 = df_fallecidos_2[['fecha_de_muerte', 'c_digo_divipola', 'ax_dias_muerte2']]
df_fallecidos_3.columns = ['fecha', 'c_digo_divipola', 'ax_dias_muerte2']
df_fallecidos_3['nuevos_fallecidos'] = 1
df_fallecidos_3

#Inofmración nuevos recuperados
df_recuperados_1 = results_df2[['fecha_recuperado', 'c_digo_divipola', 'atenci_n', 'ax_dias_recuperacion2']]
df_recuperados_2 = df_recuperados_1[df_recuperados_1.atenci_n == 'Recuperado']
df_recuperados_3 = df_recuperados_2[['fecha_recuperado', 'c_digo_divipola', 'ax_dias_recuperacion2']]
df_recuperados_3.columns = ['fecha', 'c_digo_divipola', 'ax_dias_recuperacion2']
df_recuperados_3['nuevos_recuperados'] = 1
df_recuperados_3

#Concatenar los 3 df anteriores
df_concat_1 = pd.concat([df_contagios_1, df_fallecidos_3, df_recuperados_3], axis=0)
df_concat_2 = df_concat_1[df_concat_1.c_digo_divipola.isin(['11001', '05001', '76001','13001','08001'])]
df_concat_3 = df_concat_2.reset_index().groupby( [ "c_digo_divipola", "fecha"],as_index=False ).sum()

#Cálculo de días de recuperración pormedio por fecha - ciudad
df_concat_3['dias_recuperacion_promedio'] = df_concat_3['ax_dias_recuperacion2'] / df_concat_3['nuevos_recuperados']
df_concat_3['dias_fallecido_promedio'] = df_concat_3['ax_dias_muerte2'] / df_concat_3['nuevos_fallecidos']

#Se acumula por código de ciudad para sacar los acmuluados en contagios fallecidos y recuperados
df_concat_3['acumulado_contagios'] = df_concat_3.groupby("c_digo_divipola")["nuevos_contagios"].transform(pd.Series.cumsum)
df_concat_3['acumulado_fallecidos'] = df_concat_3.groupby("c_digo_divipola")["nuevos_fallecidos"].transform(pd.Series.cumsum)
df_concat_3['acumulado_recuperados'] = df_concat_3.groupby("c_digo_divipola")["nuevos_recuperados"].transform(pd.Series.cumsum)
df_concat_3['casos_activos'] = df_concat_3['acumulado_contagios'] - df_concat_3['acumulado_fallecidos'] - df_concat_3['acumulado_recuperados']

#Merge para crear un df que contenga la información junto a la población por ciudad.
df_concat_4 = pd.merge(df_concat_3,  poblacion7, on= 'c_digo_divipola',)
df_concat_4['susceptibles'] = df_concat_4['poblacion'] - df_concat_4['acumulado_contagios']
df_concat_4

#Se divide en DF por ciudad debido a que buscamos desarrollar modelos diferentes para cada ciudad. Además, entendiendo que las dinámicas de infección y restricciones establecidas por los gobernantes son diferentes para cada una
df_concat_4_med = df_concat_4[df_concat_4.c_digo_divipola.isin(['05001'])]
df_concat_4_bog = df_concat_4[df_concat_4.c_digo_divipola.isin(['11001'])]
df_concat_4_cal = df_concat_4[df_concat_4.c_digo_divipola.isin(['76001'])]
df_concat_4_car = df_concat_4[df_concat_4.c_digo_divipola.isin(['13001'])]
df_concat_4_bar = df_concat_4[df_concat_4.c_digo_divipola.isin(['08001'])]

#cálculo de tasa de contágio por ciudad
df_concat_4_med['tasa_contagio'] = df_concat_4_med.nuevos_contagios / df_concat_4_med.casos_activos.shift(1)
df_concat_4_bog['tasa_contagio'] = df_concat_4_bog.nuevos_contagios / df_concat_4_bog.casos_activos.shift(1)
df_concat_4_cal['tasa_contagio'] = df_concat_4_cal.nuevos_contagios / df_concat_4_cal.casos_activos.shift(1)
df_concat_4_car['tasa_contagio'] = df_concat_4_car.nuevos_contagios / df_concat_4_car.casos_activos.shift(1)
df_concat_4_bar['tasa_contagio'] = df_concat_4_bar.nuevos_contagios / df_concat_4_bar.casos_activos.shift(1)
#cálculo de tasa de muerte por ciudad
df_concat_4_med['tasa_muerte'] = df_concat_4_med.nuevos_fallecidos / df_concat_4_med.casos_activos.shift(1)
df_concat_4_bog['tasa_muerte'] = df_concat_4_bog.nuevos_fallecidos / df_concat_4_bog.casos_activos.shift(1)
df_concat_4_cal['tasa_muerte'] = df_concat_4_cal.nuevos_fallecidos / df_concat_4_cal.casos_activos.shift(1)
df_concat_4_car['tasa_muerte'] = df_concat_4_car.nuevos_fallecidos / df_concat_4_car.casos_activos.shift(1)
df_concat_4_bar['tasa_muerte'] = df_concat_4_bar.nuevos_fallecidos / df_concat_4_bar.casos_activos.shift(1)
#cálculo de tasa de recuperación por ciudad
df_concat_4_med['tasa_recuperacion'] = df_concat_4_med.nuevos_recuperados / df_concat_4_med.casos_activos.shift(1)
df_concat_4_bog['tasa_recuperacion'] = df_concat_4_bog.nuevos_recuperados / df_concat_4_bog.casos_activos.shift(1)
df_concat_4_cal['tasa_recuperacion'] = df_concat_4_cal.nuevos_recuperados / df_concat_4_cal.casos_activos.shift(1)
df_concat_4_car['tasa_recuperacion'] = df_concat_4_car.nuevos_recuperados / df_concat_4_car.casos_activos.shift(1)
df_concat_4_bar['tasa_recuperacion'] = df_concat_4_bar.nuevos_recuperados / df_concat_4_bar.casos_activos.shift(1)
#cálculo de tasa de salida por ciudad
df_concat_4_med['tasa_salida'] = ((df_concat_4_med.nuevos_recuperados * df_concat_4_med.dias_recuperacion_promedio)+ (df_concat_4_med.nuevos_fallecidos * df_concat_4_med.dias_fallecido_promedio)) /(df_concat_4_med.nuevos_recuperados + df_concat_4_med.nuevos_fallecidos)
df_concat_4_bog['tasa_salida'] = ((df_concat_4_bog.nuevos_recuperados * df_concat_4_bog.dias_recuperacion_promedio)+ (df_concat_4_bog.nuevos_fallecidos * df_concat_4_bog.dias_fallecido_promedio)) /(df_concat_4_bog.nuevos_recuperados + df_concat_4_bog.nuevos_fallecidos)
df_concat_4_cal['tasa_salida'] = ((df_concat_4_cal.nuevos_recuperados * df_concat_4_cal.dias_recuperacion_promedio)+ (df_concat_4_cal.nuevos_fallecidos * df_concat_4_cal.dias_fallecido_promedio)) /(df_concat_4_cal.nuevos_recuperados + df_concat_4_cal.nuevos_fallecidos)
df_concat_4_car['tasa_salida'] = ((df_concat_4_car.nuevos_recuperados * df_concat_4_car.dias_recuperacion_promedio)+ (df_concat_4_car.nuevos_fallecidos * df_concat_4_car.dias_fallecido_promedio)) /(df_concat_4_car.nuevos_recuperados + df_concat_4_car.nuevos_fallecidos)
df_concat_4_bar['tasa_salida'] = ((df_concat_4_bar.nuevos_recuperados * df_concat_4_bar.dias_recuperacion_promedio)+ (df_concat_4_bar.nuevos_fallecidos * df_concat_4_bar.dias_fallecido_promedio)) /(df_concat_4_bar.nuevos_recuperados + df_concat_4_bar.nuevos_fallecidos)

#Quitar Na de las tasas
def correc_tasa_contagio(row):

    x = (row["tasa_contagio"])
    if x >= 0:
      return x
    elif x < 0:
      return x
    else:
      return 0

def correc_tasa_muerte(row):

    x = (row["tasa_muerte"])
    if x >= 0:
      return x
    elif x < 0:
      return x
    else:
      return 0


def correc_tasa_recuperacion(row):

    x = (row["tasa_recuperacion"])
    if x >= 0:
      return x
    elif x < 0:
      return x
    else:
      return 0

def correc_dias_recuperacion_promedio(row):

    x = (row["dias_recuperacion_promedio"])
    if x >= 0:
      return x
    elif x < 0:
      return x
    else:
      return 0

def correc_tasa_salida(row):

    x = (row["tasa_salida"])
    if x >= 0:
      return x
    elif x < 0:
      return x
    else:
      return 0

df_concat_5 =pd.concat([df_concat_4_med, df_concat_4_bog, df_concat_4_cal, df_concat_4_car, df_concat_4_bar], axis=0)

df_concat_5

#Corrección Nan persistentes en el df
df_concat_5['tasa_contagio'] = df_concat_5.apply(correc_tasa_contagio, axis=1)
df_concat_5['tasa_muerte'] = df_concat_5.apply(correc_tasa_muerte, axis=1)
df_concat_5['tasa_recuperacion'] = df_concat_5.apply(correc_tasa_recuperacion, axis=1)
df_concat_5['dias_recuperacion_promedio'] = df_concat_5.apply(correc_dias_recuperacion_promedio, axis=1)
df_concat_5['tasa_salida'] = df_concat_5.apply(correc_tasa_salida, axis=1)
df_concat_5

"""#Preparación de datos para el modelado

Justo antes de iniciar el proceso de modelado de los datos es pertinente realizar una división de los datos entre:

- Dataset de entrenamiento
- Dataset de prueba

El dataset de entrenamiento buesca definir un modelo a través del cual se pueda modelar el comportamiento de un fenómeno. El dataset de prueba, evaluará la capacidad de predecir los comportamientos futuros de dicho fenómeno, para nuestro caso de aplicación evaluará la cantidad de infectados, recuperados, fallecidos, entre otros.
"""

#Dividir el dataset en dos: entrenamiento y prueba. Para esto se excluyen los últimos 5 días para el set de entrenamiento, y pruebas y validación los últimos 3 días. Los últimos 2 días se separan debido a que son suceptibles a ajustes y errores de captura.

today = date.today() - timedelta(days=5)
today2 = date.today() - timedelta(days=2)
today = pd.to_datetime(today)
today2 = pd.to_datetime(today2)

df_concat_5_train = df_concat_5[df_concat_5.fecha <= today]
df_concat_5_check = df_concat_5[df_concat_5.fecha > today]
df_concat_5_check = df_concat_5_check[df_concat_5_check.fecha <= today2]
df_concat_5_test = df_concat_5[df_concat_5.fecha > today2]
df_concat_5_train
#df_concat_5_check

# Definición de variables para ciclo de optimización
df_concat_5_train_med = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['05001'])]
df_concat_5_train_bog = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['11001'])]
df_concat_5_train_cal = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['76001'])]
df_concat_5_train_car = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['13001'])]
df_concat_5_train_bar = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['08001'])]

#Esta es la información real para comparar con la información de la predicción
comprobar_med = df_concat_5[df_concat_5.c_digo_divipola.isin(['05001'])]
comprobar_bog = df_concat_5[df_concat_5.c_digo_divipola.isin(['11001'])]
comprobar_cal = df_concat_5[df_concat_5.c_digo_divipola.isin(['76001'])]
comprobar_car = df_concat_5[df_concat_5.c_digo_divipola.isin(['13001'])]
comprobar_bar = df_concat_5[df_concat_5.c_digo_divipola.isin(['08001'])]

#Definición de la población es necesario
poblacion_med = int(df_concat_5_train_med.poblacion.unique())
poblacion_bog = int(df_concat_5_train_bog.poblacion.unique())
poblacion_cal = int(df_concat_5_train_cal.poblacion.unique())
poblacion_car = int(df_concat_5_train_car.poblacion.unique())
poblacion_bar = int(df_concat_5_train_bar.poblacion.unique())

comprobar_med_2 = comprobar_med[['casos_activos']]
comprobar_bog_2 = comprobar_bog[['casos_activos']]
comprobar_cal_2 = comprobar_cal[['casos_activos']]
comprobar_car_2 = comprobar_car[['casos_activos']]
comprobar_bar_2 = comprobar_bar[['casos_activos']]

comprobar_med_2.reset_index(drop=True, inplace=True)
comprobar_bog_2.reset_index(drop=True, inplace=True)
comprobar_cal_2.reset_index(drop=True, inplace=True)
comprobar_car_2.reset_index(drop=True, inplace=True)
comprobar_bar_2.reset_index(drop=True, inplace=True)

y_true_med = comprobar_med_2.values
y_true_bog = comprobar_bog_2.values
y_true_cal = comprobar_cal_2.values
y_true_car = comprobar_car_2.values
y_true_bar = comprobar_bar_2.values

#Variables para definir el rango óptimo para calcular el promedio de las tasas e implementaro en el modelo predictivo
variable_tail_med_opt = 0
variable_tail_bog_opt = 0
variable_tail_cal_opt = 0
variable_tail_car_opt = 0
variable_tail_bar_opt = 0

"""#Modelado

En la fase de modelado se seleccionan y aplican las técnicas de modelado que tengan una mejor aproximación al evento en estudio. Para el caso de fenómenos epidemiológicos se seleccionaron dos modelos a evaluar:

- Modelo SIR
- Modelo regresión logística  

A través de los cuales se busca representar el comportamiento de contagios del Covid 19 en las principales ciudades de Colombia, evaluando la exactitud de esto y posteriormente calibrando sus parámetros hasta encontrar los valores que optimicen los resultados del pronóstico.

##Modelo SIR

El modelo SIR es un modelo epidemiológico con la capacidad de de capturar las características comunes para fenómenos de virus o brotes epidémicos. Su nombre proviene de las iniciales S (población susceptible), I (población infectada) y R (población recuperada). El modelo está fundamentado en relacionar las variaciones de las tres poblaciones (Susceptible, Infectada y Recuperada) a través de la tasa de infección y el período infeccioso promedio, usando el concepto de derivadas para determinar las velocidades de contagio de la población suceptible, y la velocidad de recuperación de los infectados. Sin embargo, cabe notar que este modelo no incluye las personas fallecidas.

Para efectos de este proyecto se determinó incluir los fallecidos a través de la interpretación que la tasa de salida o recuperados del modelo original. Es decir, los recuperados del modelo SIR, hacen referencia a las personas que no están infectadas, para nuestro caso de aplicación al Covid existe la posibilidad de salir del estado de infectado al recuperarse o morir. Considerando la alta tasa de mortalidad de este virus, se redefinió recuperados por tasa de salida, la cual está compuesta por recuperados y fallecidos.

###Ciclo de optimización
"""

#Implementación del Modelo SIR

#Ciclo de Inicialización de variables
dif_med_acum = 0
dif_bog_acum = 0
dif_cal_acum = 0
dif_car_acum = 0
dif_bar_acum = 0

#num_med = 0
#num_bog = 0
#num_cal = 0
#num_car = 0
#num_bar = 0

#den_med = 0
#den_bog = 0
#den_cal = 0
#den_car = 0
#den_bar = 0

dif_med = 0
dif_bog = 0
dif_cal = 0
dif_car = 0
dif_bar = 0

# Ciclo de optimización para determinar el tails con menos error ponderado (MAPE)
maximo = max(len(df_concat_5_train_med), 
             len(df_concat_5_train_bog), 
             len(df_concat_5_train_cal), 
             len(df_concat_5_train_car), 
             len(df_concat_5_train_bar))

maximo = maximo + 1

for i in range(1, maximo):

  #Definiciín de variables tail por ciudad
  variable_tail_med = i
  variable_tail_bog = i
  variable_tail_cal = i
  variable_tail_car = i
  variable_tail_bar = i

  #extracción de los datos para sacar parámetros del modelo
  df_concat_5_train_med_2 = df_concat_5_train_med.tail(variable_tail_med)
  df_concat_5_train_bog_2 = df_concat_5_train_bog.tail(variable_tail_bog)
  df_concat_5_train_cal_2 = df_concat_5_train_cal.tail(variable_tail_cal)
  df_concat_5_train_car_2 = df_concat_5_train_car.tail(variable_tail_car)
  df_concat_5_train_bar_2 = df_concat_5_train_bar.tail(variable_tail_bar)

  #Se calculan las medias por ciudad
  media_contagios_med = stats.mean(df_concat_5_train_med_2.tasa_contagio)
  media_muerte_med = stats.mean(df_concat_5_train_med_2.tasa_muerte)
  media_recuperacion_med = stats.mean(df_concat_5_train_med_2.tasa_recuperacion)

  media_contagios_bog = stats.mean(df_concat_5_train_bog_2.tasa_contagio)
  media_muerte_bog = stats.mean(df_concat_5_train_bog_2.tasa_muerte)
  media_recuperacion_bog = stats.mean(df_concat_5_train_bog_2.tasa_recuperacion)

  media_contagios_cal = stats.mean(df_concat_5_train_cal_2.tasa_contagio)
  media_muerte_cal = stats.mean(df_concat_5_train_cal_2.tasa_muerte)
  media_recuperacion_cal = stats.mean(df_concat_5_train_cal_2.tasa_recuperacion)

  media_contagios_car = stats.mean(df_concat_5_train_car_2.tasa_contagio)
  media_muerte_car = stats.mean(df_concat_5_train_car_2.tasa_muerte)
  media_recuperacion_car = stats.mean(df_concat_5_train_car_2.tasa_recuperacion)

  media_contagios_bar = stats.mean(df_concat_5_train_bar_2.tasa_contagio)
  media_muerte_bar = stats.mean(df_concat_5_train_bar_2.tasa_muerte)
  media_recuperacion_bar = stats.mean(df_concat_5_train_bar_2.tasa_recuperacion)

  #Se calculan los días de recuperación promedio por ciudad -- parámetro de los modelos

  df_concat_5_train_med_3 = df_concat_5_train_med[df_concat_5_train_med.nuevos_recuperados != 0]
  df_concat_5_train_bog_3 = df_concat_5_train_bog[df_concat_5_train_bog.nuevos_recuperados != 0]
  df_concat_5_train_cal_3 = df_concat_5_train_cal[df_concat_5_train_cal.nuevos_recuperados != 0]
  df_concat_5_train_car_3 = df_concat_5_train_car[df_concat_5_train_car.nuevos_recuperados != 0]
  df_concat_5_train_bar_3 = df_concat_5_train_bar[df_concat_5_train_bar.nuevos_recuperados != 0]

  df_concat_5_train_med_4 = df_concat_5_train_med_3.tail(variable_tail_med)
  df_concat_5_train_bog_4 = df_concat_5_train_bog_3.tail(variable_tail_bog)
  df_concat_5_train_cal_4 = df_concat_5_train_cal_3.tail(variable_tail_cal)
  df_concat_5_train_car_4 = df_concat_5_train_car_3.tail(variable_tail_car)
  df_concat_5_train_bar_4 = df_concat_5_train_bar_3.tail(variable_tail_bar)

  media_dias_rec_med = stats.mean(df_concat_5_train_med_4.dias_recuperacion_promedio)
  media_dias_rec_bog = stats.mean(df_concat_5_train_bog_4.dias_recuperacion_promedio)
  media_dias_rec_cal = stats.mean(df_concat_5_train_cal_4.dias_recuperacion_promedio)
  media_dias_rec_car = stats.mean(df_concat_5_train_car_4.dias_recuperacion_promedio)
  media_dias_rec_bar = stats.mean(df_concat_5_train_bar_4.dias_recuperacion_promedio)


  media_dias_salida_med = stats.mean(df_concat_5_train_med_4.tasa_salida)
  media_dias_salida_bog = stats.mean(df_concat_5_train_bog_4.tasa_salida)
  media_dias_salida_cal = stats.mean(df_concat_5_train_cal_4.tasa_salida)
  media_dias_salida_car = stats.mean(df_concat_5_train_car_4.tasa_salida)
  media_dias_salida_bar = stats.mean(df_concat_5_train_bar_4.tasa_salida)

  #Modelo de predicción

  #import matplotlib.pyplot as plt

  #ciudades
  # N es igual a la población de cada ciudad
  #Con Tail modelo original
  #valores = [(media_contagios_med,1/media_dias_rec_med,poblacion_med), 
  #           (media_contagios_bog,1/media_dias_rec_bog,poblacion_bog),
  #           (media_contagios_cal,1/media_dias_rec_cal,poblacion_cal),
  #           (media_contagios_car,1/media_dias_rec_car,poblacion_car),
  #           (media_contagios_bar,1/media_dias_rec_bar,poblacion_bar)]
  #Con Tasa de salida
  valores = [(media_contagios_med,1/media_dias_salida_med,poblacion_med, 'Medellín'), 
           (media_contagios_bog,1/media_dias_salida_bog,poblacion_bog, 'Bogotá D.C.'),
           (media_contagios_cal,1/media_dias_salida_cal,poblacion_cal, 'Cali'),
           (media_contagios_car,1/media_dias_salida_car,poblacion_car, 'Cartagena'),
           (media_contagios_bar,1/media_dias_salida_bar,poblacion_bar, 'Barranquilla')]
  #Con Tasa de salida - Modelo híbrido - Juan-Daniel
  #valores = [(media_contagios_med/media_recuperacion_med,1/media_dias_salida_med,poblacion_med), 
  #           (media_contagios_bog/media_recuperacion_bog,1/media_dias_salida_bog,poblacion_bog),
  #           (media_contagios_cal/media_recuperacion_cal,1/media_dias_salida_cal,poblacion_cal),
  #           (media_contagios_car/media_recuperacion_car,1/media_dias_salida_car,poblacion_car),
  #           (media_contagios_bar/media_recuperacion_bar,1/media_dias_salida_bar,poblacion_bar)]
  #Con media de contagio como gama
  #valores = [(media_contagios_med/media_recuperacion_med,media_contagios_med,poblacion_med), 
  #           (media_contagios_bog/media_recuperacion_bog,media_contagios_bog,poblacion_bog),
  #           (media_contagios_cal/media_recuperacion_cal,media_contagios_cal,poblacion_cal),
  #           (media_contagios_car/media_recuperacion_car,media_contagios_car,poblacion_car),
  #           (media_contagios_bar/media_recuperacion_bar,media_contagios_bar,poblacion_bar)]
  #Con TASA recuperados
  #valores = [(media_contagios_med,media_recuperacion_med/media_dias_salida_med,poblacion_med), 
  #           (media_contagios_bog,media_recuperacion_bog/media_dias_salida_bog,poblacion_bog),
  #           (media_contagios_cal,media_recuperacion_cal/media_dias_salida_cal,poblacion_cal),
  #           (media_contagios_car,media_recuperacion_car/media_dias_salida_car,poblacion_car),
  #           (media_contagios_bar,media_recuperacion_bar/media_dias_salida_bar,poblacion_bar)]

  #valores = [(media_contagios_med,media_recuperacion_med,poblacion_med), 
  #          (media_contagios_bog,media_recuperacion_bog,poblacion_bog),
  #          (media_contagios_cal,media_recuperacion_cal,poblacion_cal),
  #          (media_contagios_car,media_recuperacion_car,poblacion_car),
  #          (media_contagios_bar,media_recuperacion_bar,poblacion_bar)]
  #Con R: reproducción optima del modelo
  #valores = [(media_contagios_med/media_recuperacion_med,1/media_dias_rec_med,poblacion_med), 
  #          (media_contagios_bog/media_recuperacion_bog,1/media_dias_rec_bog,poblacion_bog),
  #          (media_contagios_cal/media_recuperacion_cal,1/media_dias_rec_cal,poblacion_cal),
  #          (media_contagios_car/media_recuperacion_car,1/media_dias_rec_car,poblacion_car),
  #          (media_contagios_bar/media_recuperacion_bar,1/media_dias_rec_bar,poblacion_bar)]
  #Con R inverso: reproducción optima del modelo
  #valores = [(media_recuperacion_med/media_contagios_med,1/media_dias_rec_med,poblacion_med), 
  #          (media_recuperacion_bog/media_contagios_bog,1/media_dias_rec_bog,poblacion_bog),
  #          (media_recuperacion_cal/media_contagios_cal,1/media_dias_rec_cal,poblacion_cal),
  #          (media_recuperacion_car/media_contagios_car,1/media_dias_rec_car,poblacion_car),
  #          (media_recuperacion_bar/media_contagios_bar,1/media_dias_rec_bar,poblacion_bar)]
  #Con R inverso: reproducción optima del modelo con solo media de recuperados para gama
  #valores = [(media_recuperacion_med/media_contagios_med,media_recuperacion_med,poblacion_med), 
  #          (media_recuperacion_bog/media_contagios_bog,media_recuperacion_bog,poblacion_bog),
  #          (media_recuperacion_cal/media_contagios_cal,media_recuperacion_cal,poblacion_cal),
  #          (media_recuperacion_car/media_contagios_car,media_recuperacion_car,poblacion_car),
  #          (media_recuperacion_bar/media_contagios_bar,media_recuperacion_bar,poblacion_bar)]

  #Tasa constante
  #valores = [(0.09,media_recuperacion_med/media_dias_salida_med,poblacion_med), 
  #           (0.09,media_recuperacion_bog/media_dias_salida_bog,poblacion_bog),
  #           (0.09,media_recuperacion_cal/media_dias_salida_cal,poblacion_cal),
  #           (0.09,media_recuperacion_car/media_dias_salida_car,poblacion_car),
  #           (0.09,media_recuperacion_bar/media_dias_salida_bar,poblacion_bar)]
  #Valor constante - juan
  #valores = [(1,1/media_dias_salida_med,poblacion_med), 
  #           (1,1/media_dias_salida_bog,poblacion_bog),
  #           (1,1/media_dias_salida_cal,poblacion_cal),
  #           (1,1/media_dias_salida_car,poblacion_car),
  #           (1,1/media_dias_salida_bar,poblacion_bar)]

  #valores = [(media_contagios_med,1/media_dias_rec_med,10000), 
  #           (media_contagios_bog,1/media_dias_rec_bog,10000),
  #           (media_contagios_cal,1/media_dias_rec_cal,10000),
  #           (media_contagios_car,1/media_dias_rec_car,10000),
  #           (media_contagios_bar,1/media_dias_rec_bar,10000)]

  t = np.linspace(0, 360, 360)

  def modelo(beta, gamma, N, ciudad):
    # valores iniciales infectados (I0) y personas que se recuperan (R0)
    I0, R0 = 1,0
    # población suceptible
    S0 = N - I0 - R0
    # puntos en la gráfica
    t = np.linspace(0, 360, 360)
    # The SIR model differential equations.
    def deriv(y, t, N, beta, gamma):
      S, I, R = y
      dSdt = -beta * S * I / N
      dIdt = beta * S * I / N - gamma * I
      dRdt = gamma * I
      return dSdt, dIdt, dRdt
    # Vector de las condiciones iniciales
    y0 = S0, I0, R0
    # Resolver el sistema de ecuaciones diferenciales, en la secuencia de días que ya definimos
    ret = odeint(deriv, y0, t, args=(N, beta, gamma))
    S, I, R = ret.T
    return (I)

  #estracción set de prueba para intervalos de confianza
  y_pred_med = modelo(*valores[0])
  y_pred_bog = modelo(*valores[1])
  y_pred_cal = modelo(*valores[2])
  y_pred_car = modelo(*valores[3])
  y_pred_bar = modelo(*valores[4])

  array_to_df_med = pd.DataFrame(y_pred_med)
  array_to_df_bog = pd.DataFrame(y_pred_bog)
  array_to_df_cal = pd.DataFrame(y_pred_cal)
  array_to_df_car = pd.DataFrame(y_pred_car)
  array_to_df_bar = pd.DataFrame(y_pred_bar)

  array_to_df_med.reset_index(drop=True, inplace=True)
  array_to_df_bog.reset_index(drop=True, inplace=True)
  array_to_df_cal.reset_index(drop=True, inplace=True)
  array_to_df_car.reset_index(drop=True, inplace=True)
  array_to_df_bar.reset_index(drop=True, inplace=True)

  y_pred_med2 = array_to_df_med.values
  y_pred_bog2 = array_to_df_bog.values
  y_pred_cal2 = array_to_df_cal.values
  y_pred_car2 = array_to_df_car.values
  y_pred_bar2 = array_to_df_bar.values

  y_pred_med3 = y_pred_med2[:int(len(y_true_med))]
  y_pred_bog3 = y_pred_bog2[:int(len(y_true_bog))]
  y_pred_cal3 = y_pred_cal2[:int(len(y_true_cal))]
  y_pred_car3 = y_pred_car2[:int(len(y_true_car))]
  y_pred_bar3 = y_pred_bar2[:int(len(y_true_bar))]




  #dif_med = abs(y_pred_med2[int(len(df_concat_5_train_med_2)-1)] - y_true_med[int(len(df_concat_5_train_med_2)-1)])
  #dif_bog = abs(y_pred_bog2[int(len(df_concat_5_train_bog_2)-1)] - y_true_bog[int(len(df_concat_5_train_bog_2)-1)])
  #dif_cal = abs(y_pred_cal2[int(len(df_concat_5_train_cal_2)-1)] - y_true_cal[int(len(df_concat_5_train_cal_2)-1)])
  #dif_car = abs(y_pred_car2[int(len(df_concat_5_train_car_2)-1)] - y_true_car[int(len(df_concat_5_train_car_2)-1)])
  #dif_bar = abs(y_pred_bar2[int(len(df_concat_5_train_bar_2)-1)] - y_true_bar[int(len(df_concat_5_train_bar_2)-1)])


  dif_med = np.mean(np.abs((y_true_med - y_pred_med3) / y_true_med)) * 100
  dif_bog = np.mean(np.abs((y_true_bog - y_pred_bog3) / y_true_bog)) * 100
  dif_cal = np.mean(np.abs((y_true_cal - y_pred_cal3) / y_true_cal)) * 100
  dif_car = np.mean(np.abs((y_true_car - y_pred_car3) / y_true_car)) * 100
  dif_bar = np.mean(np.abs((y_true_bar - y_pred_bar3) / y_true_bar)) * 100

  #num_med = np.sum(np.abs((y_true_med - y_pred_med3))) * 100
  #den_med = np.sum(y_true_med)
  #dif_med = num_med/den_med
  #num_bog = np.sum(np.abs((y_true_bog - y_pred_bog3))) * 100
  #den_bog = np.sum(y_true_bog)
  #dif_bog = num_bog/den_bog
  #num_cal = np.sum(np.abs((y_true_cal - y_pred_cal3))) * 100
  #den_cal = np.sum(y_true_cal)
  #dif_cal = num_cal/den_cal
  #num_car = np.sum(np.abs((y_true_car - y_pred_car3))) * 100
  #den_car = np.sum(y_true_car)
  #dif_car = num_car/den_car
  #num_bar = np.sum(np.abs((y_true_bar - y_pred_bar3))) * 100
  #den_bar = np.sum(y_true_bar)
  #dif_bar = num_bar/den_bar


  if i==1:
    dif_med_acum = dif_med
    dif_bog_acum = dif_bog
    dif_cal_acum = dif_cal
    dif_car_acum = dif_car
    dif_bar_acum = dif_bar

  if dif_med < dif_med_acum:
    dif_med_acum = dif_med
    variable_tail_med_opt = variable_tail_med
  
  if dif_bog < dif_bog_acum:
    dif_bog_acum = dif_bog
    variable_tail_bog_opt = variable_tail_bog

  if dif_cal < dif_cal_acum:
    dif_cal_acum = dif_cal
    variable_tail_cal_opt = variable_tail_cal

  if dif_car < dif_car_acum:
    dif_car_acum = dif_car
    variable_tail_car_opt = variable_tail_car

  if dif_bar < dif_bar_acum:
    dif_bar_acum = dif_bar
    variable_tail_bar_opt = variable_tail_bar

"""Parámetros que optimizan el modelo SIR, a través de la consideración de los x últimos días del dataset de entrenamiento para lograr el menor error ponderado o MAPE en los pronósticos de infectados por ciudad.

A continuación de presentan los Tails óptimos por ciudad:
"""

print('Tail óptimo Medellín:', variable_tail_med_opt, "últimos datos del dataset de entrenamiento")
print('Tail óptimo Bogotá:', variable_tail_bog_opt, "últimos datos del dataset de entrenamiento")
print('Tail óptimo Cali:', variable_tail_cal_opt, "últimos datos del dataset de entrenamiento")
print('Tail óptimo Cartagena:', variable_tail_car_opt, "últimos datos del dataset de entrenamiento")
print('Tail óptimo Barranquilla:', variable_tail_bar_opt, "últimos datos del dataset de entrenamiento")

#Sacar las tasas por ciudades
#Se divide en DF por ciudad
df_concat_5_train_med = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['05001'])]
df_concat_5_train_bog = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['11001'])]
df_concat_5_train_cal = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['76001'])]
df_concat_5_train_car = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['13001'])]
df_concat_5_train_bar = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['08001'])]

df_concat_5_train_med_2 = df_concat_5_train_med.tail(variable_tail_med_opt)
df_concat_5_train_bog_2 = df_concat_5_train_bog.tail(variable_tail_bog_opt)
df_concat_5_train_cal_2 = df_concat_5_train_cal.tail(variable_tail_cal_opt)
df_concat_5_train_car_2 = df_concat_5_train_car.tail(variable_tail_car_opt)
df_concat_5_train_bar_2 = df_concat_5_train_bar.tail(variable_tail_bar_opt)

#Se calculan las medias por ciudad
media_contagios_med = stats.mean(df_concat_5_train_med_2.tasa_contagio)
media_muerte_med = stats.mean(df_concat_5_train_med_2.tasa_muerte)
media_recuperacion_med = stats.mean(df_concat_5_train_med_2.tasa_recuperacion)

media_contagios_bog = stats.mean(df_concat_5_train_bog_2.tasa_contagio)
media_muerte_bog = stats.mean(df_concat_5_train_bog_2.tasa_muerte)
media_recuperacion_bog = stats.mean(df_concat_5_train_bog_2.tasa_recuperacion)

media_contagios_cal = stats.mean(df_concat_5_train_cal_2.tasa_contagio)
media_muerte_cal = stats.mean(df_concat_5_train_cal_2.tasa_muerte)
media_recuperacion_cal = stats.mean(df_concat_5_train_cal_2.tasa_recuperacion)

media_contagios_car = stats.mean(df_concat_5_train_car_2.tasa_contagio)
media_muerte_car = stats.mean(df_concat_5_train_car_2.tasa_muerte)
media_recuperacion_car = stats.mean(df_concat_5_train_car_2.tasa_recuperacion)

media_contagios_bar = stats.mean(df_concat_5_train_bar_2.tasa_contagio)
media_muerte_bar = stats.mean(df_concat_5_train_bar_2.tasa_muerte)
media_recuperacion_bar = stats.mean(df_concat_5_train_bar_2.tasa_recuperacion)

#Se calculan los días de recuperación promedio por ciudad -- parámetro de los modelos
df_concat_5_train_med_3 = df_concat_5_train_med[df_concat_5_train_med.nuevos_recuperados != 0]
df_concat_5_train_bog_3 = df_concat_5_train_bog[df_concat_5_train_bog.nuevos_recuperados != 0]
df_concat_5_train_cal_3 = df_concat_5_train_cal[df_concat_5_train_cal.nuevos_recuperados != 0]
df_concat_5_train_car_3 = df_concat_5_train_car[df_concat_5_train_car.nuevos_recuperados != 0]
df_concat_5_train_bar_3 = df_concat_5_train_bar[df_concat_5_train_bar.nuevos_recuperados != 0]

df_concat_5_train_med_4 = df_concat_5_train_med_3.tail(variable_tail_med_opt)
df_concat_5_train_bog_4 = df_concat_5_train_bog_3.tail(variable_tail_bog_opt)
df_concat_5_train_cal_4 = df_concat_5_train_cal_3.tail(variable_tail_cal_opt)
df_concat_5_train_car_4 = df_concat_5_train_car_3.tail(variable_tail_car_opt)
df_concat_5_train_bar_4 = df_concat_5_train_bar_3.tail(variable_tail_bar_opt)

media_dias_rec_med = stats.mean(df_concat_5_train_med_4.dias_recuperacion_promedio)
media_dias_rec_bog = stats.mean(df_concat_5_train_bog_4.dias_recuperacion_promedio)
media_dias_rec_cal = stats.mean(df_concat_5_train_cal_4.dias_recuperacion_promedio)
media_dias_rec_car = stats.mean(df_concat_5_train_car_4.dias_recuperacion_promedio)
media_dias_rec_bar = stats.mean(df_concat_5_train_bar_4.dias_recuperacion_promedio)

media_dias_salida_med = stats.mean(df_concat_5_train_med_4.tasa_salida)
media_dias_salida_bog = stats.mean(df_concat_5_train_bog_4.tasa_salida)
media_dias_salida_cal = stats.mean(df_concat_5_train_cal_4.tasa_salida)
media_dias_salida_car = stats.mean(df_concat_5_train_car_4.tasa_salida)
media_dias_salida_bar = stats.mean(df_concat_5_train_bar_4.tasa_salida)

#Definición de la población
poblacion_med = int(df_concat_5_train_med.poblacion.unique())
poblacion_bog = int(df_concat_5_train_bog.poblacion.unique())
poblacion_cal = int(df_concat_5_train_cal.poblacion.unique())
poblacion_car = int(df_concat_5_train_car.poblacion.unique())
poblacion_bar = int(df_concat_5_train_bar.poblacion.unique())

"""###Intervalos de confianza SIR"""

#Desviación estandar e intervalos de confianza para la predicción de SIR 
y_pred_med3 =y_pred_med[len(y_true_med):len(y_true_med)+90]
miu_med = np.mean(y_pred_med3)
cuadrado_med = (y_pred_med3 - miu_med)**2
suma_med = sum(cuadrado_med)
div_med = suma_med / len(cuadrado_med)
desviacion_estandar_med = div_med ** (1/2)
li_med = miu_med - 1.96*(desviacion_estandar_med/((len(cuadrado_med))**(1/2)))
ls_med = miu_med + 1.96*(desviacion_estandar_med/((len(cuadrado_med))**(1/2)))
valor_int_med = ls_med - miu_med

y_pred_bog3 =y_pred_bog[len(y_true_bog):len(y_true_bog)+90]
miu_bog = np.mean(y_pred_bog3)
cuadrado_bog = (y_pred_bog3 - miu_bog)**2
suma_bog = sum(cuadrado_bog)
div_bog = suma_bog / len(cuadrado_bog)
desviacion_estandar_bog = div_bog ** (1/2)
li_bog = miu_bog - 1.96*(desviacion_estandar_bog/((len(cuadrado_bog))**(1/2)))
ls_bog = miu_bog + 1.96*(desviacion_estandar_bog/((len(cuadrado_bog))**(1/2)))
valor_int_bog = ls_bog - miu_bog

y_pred_cal3 =y_pred_cal[len(y_true_cal):len(y_true_cal)+90]
miu_cal = np.mean(y_pred_cal3)
cuadrado_cal = (y_pred_cal3 - miu_cal)**2
suma_cal = sum(cuadrado_cal)
div_cal = suma_cal / len(cuadrado_cal)
desviacion_estandar_cal = div_cal ** (1/2)
li_cal = miu_cal - 1.96*(desviacion_estandar_cal/((len(cuadrado_cal))**(1/2)))
ls_cal = miu_cal + 1.96*(desviacion_estandar_cal/((len(cuadrado_cal))**(1/2)))
valor_int_cal = ls_cal - miu_cal

y_pred_car3 =y_pred_car[len(y_true_car):len(y_true_car)+90]
miu_car = np.mean(y_pred_car3)
cuadrado_car = (y_pred_car3 - miu_car)**2
suma_car = sum(cuadrado_car)
div_car = suma_car / len(cuadrado_car)
desviacion_estandar_car = div_car ** (1/2)
li_car = miu_car - 1.96*(desviacion_estandar_car/((len(cuadrado_car))**(1/2)))
ls_car = miu_car + 1.96*(desviacion_estandar_car/((len(cuadrado_car))**(1/2)))
valor_int_car = ls_car - miu_car

y_pred_bar3 =y_pred_bar[len(y_true_bar):len(y_true_bar)+90]
miu_bar = np.mean(y_pred_bar3)
cuadrado_bar = (y_pred_bar3 - miu_bar)**2
suma_bar = sum(cuadrado_bar)
div_bar = suma_bar / len(cuadrado_bar)
desviacion_estandar_bar = div_bar ** (1/2)
li_bar = miu_bar - 1.96*(desviacion_estandar_bar/((len(cuadrado_bar))**(1/2)))
ls_bar = miu_bar + 1.96*(desviacion_estandar_bar/((len(cuadrado_bar))**(1/2)))
valor_int_bar = ls_bar - miu_bar

valor_intervalos = [(valor_int_med),
                    (valor_int_bog),
                    (valor_int_cal),
                    (valor_int_car),
                    (valor_int_bar)]

intervalos_ls = [(ls_med),
                 (ls_bog),
                 (ls_cal),
                 (ls_car),
                 (ls_bar)]    

intervalos_li = [(li_med),
                 (li_bog),
                 (li_cal),
                 (li_car),
                 (li_bar)]

#estracción set de prueba para intervalos de confianza
y_pred_med = modelo(*valores[0])
y_pred_bog = modelo(*valores[1])
y_pred_cal = modelo(*valores[2])
y_pred_car = modelo(*valores[3])
y_pred_bar = modelo(*valores[4])

array_to_df_med = pd.DataFrame(y_pred_med)
array_to_df_bog = pd.DataFrame(y_pred_bog)
array_to_df_cal = pd.DataFrame(y_pred_cal)
array_to_df_car = pd.DataFrame(y_pred_car)
array_to_df_bar = pd.DataFrame(y_pred_bar)

array_to_df_med.reset_index(drop=True, inplace=True)
array_to_df_bog.reset_index(drop=True, inplace=True)
array_to_df_cal.reset_index(drop=True, inplace=True)
array_to_df_car.reset_index(drop=True, inplace=True)
array_to_df_bar.reset_index(drop=True, inplace=True)

y_pred_med2 = array_to_df_med.values
y_pred_bog2 = array_to_df_bog.values
y_pred_cal2 = array_to_df_cal.values
y_pred_car2 = array_to_df_car.values
y_pred_bar2 = array_to_df_bar.values

"""###Modelo SIR para las 5 ciudades seleccionadas

Después de haber evaluado algunas variaciones de parámetros, presentamos el modelo definitivo con el cual se realizarán los pronósticos de mediano plazo.

Se presenta una gráfica con las 5 ciudades principales, donde se evidencia que Bogotá es la que representa mayor número de contagiados, después Medellín, en tercer lugar Cali, cuarto Cartagena y por último Barranquilla.
"""

#Con Tasa de salida
valores = [(media_contagios_med,1/media_dias_salida_med,poblacion_med, 'Medellín'), 
           (media_contagios_bog,1/media_dias_salida_bog,poblacion_bog, 'Bogotá D.C.'),
           (media_contagios_cal,1/media_dias_salida_cal,poblacion_cal, 'Cali'),
           (media_contagios_car,1/media_dias_salida_car,poblacion_car, 'Cartagena'),
           (media_contagios_bar,1/media_dias_salida_bar,poblacion_bar, 'Barranquilla')]

ciudades_graf = [('Medellín'),
                 ('Bogotá D.C.'),
                 ('Cali'),
                 ('Cartagena'),
                 ('Barranquilla')]

t = np.linspace(0, 360, 360)

def modelo(beta, gamma, N, ciudad):
  # valores iniciales infectados (I0) y personas que se recuperan (R0)
  I0, R0 = 1,0
  # población suceptible
  S0 = N - I0 - R0
  # puntos en la gráfica
  t = np.linspace(0, 360, 360)
  # The SIR model differential equations.
  def deriv(y, t, N, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I / N
    dIdt = beta * S * I / N - gamma * I
    dRdt = gamma * I
    return dSdt, dIdt, dRdt
  # Vector de las condiciones iniciales
  y0 = S0, I0, R0
  # Resolver el sistema de ecuaciones diferenciales, en la secuencia de días que ya definimos
  ret = odeint(deriv, y0, t, args=(N, beta, gamma))
  S, I, R = ret.T
  return (I)

import cufflinks as cf
import plotly.offline as py

py.iplot([{
   'x': t,
   'y': modelo(*valor),
   'name': str(valor[3]),
}  for valor in valores], filename='cufflinks/multiple-lines-on-same-chart', )

"""###Modelo SIR por ciudad

A continuación se presenta una gráfica por ciudad con el modelo optimizado, tomando las datos históricos o tail del dataset de entrenamiento que reducen el error ponderado del pronóstico (MAPE).
"""

#SIR 1 - Para sacar la imagen de cada ciudad -
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
for i in [0, 1, 2, 3, 4]:

  #i = 3 
  # Total population, N.
  #N = poblacion_med
  # Initial number of infected and recovered individuals, I0 and R0.
  I0, R0 = 1, 0
  # Everyone else, S0, is susceptible to infection initially.

  # Contact rate, beta, and mean recovery rate, gamma, (in 1/days).
  #beta, gamma = media_contagios_med, 1/media_dias_rec_med 
  beta, gamma, N = 0, 0, 0
  beta, gamma, N , ciudades = valores[i]
  S0 = N - I0 - R0  
  # A grid of time points (in days)
  t = np.linspace(0, 360, 360)

  # The SIR model differential equations.
  def deriv(y, t, N, beta, gamma):
      S, I, R = y
      dSdt = -beta * S * I / N
      dIdt = beta * S * I / N - gamma * I
      dRdt = gamma * I
      return dSdt, dIdt, dRdt

  # Initial conditions vector
  y0 = S0, I0, R0
  # Integrate the SIR equations over the time grid, t.
  ret = odeint(deriv, y0, t, args=(N, beta, gamma))
  S, I, R = ret.T

  # Plot the data on three separate curves for S(t), I(t) and R(t)
  fig = plt.figure(facecolor='w')
  ax = fig.add_subplot(111, facecolor='#dddddd', axisbelow=True)
  ax.plot(t, S, 'b', alpha=0.5, lw=4, label='Susceptibles')
  ax.plot(t, I+valor_intervalos[i], 'black', alpha=0.5, lw=2, label='Infectados Ls')
  ax.plot(t, I, 'r', alpha=0.5, lw=4, label='Infectados')
  ax.plot(t, I-valor_intervalos[i], 'black', alpha=0.5, lw=2, label='Infectados Li')
  ax.plot(t, R, 'g', alpha=0.5, lw=4, label='Recuperados y Fallecidos')
  #ax.plot(t, S, 'y' )
  ax.set_xlabel('Días', fontsize=20)
  ax.set_ylabel('Number', fontsize=20)
  #ax.set_ylim(0,3000000)
  #ax.yaxis.set_tick_params(length=0)
  #ax.xaxis.set_tick_params(length=0)
  #ax.grid(b=True, which='major', c='w', lw=2, ls='-')
  #legend = ax.legend()
  plt.yticks(ax.get_yticks(), ax.get_yticks() * 1)
  plt.legend(["Susceptibles", "Infectados Ls", "Infectados", "Infectados Li", "Recuperados y Fallecidos"], prop={'size': 20})
  plt.xticks(fontsize=15)
  plt.yticks(fontsize=15)
  plt.rc('figure', figsize=(35, 12))

  v_text = "Ls: " + str('{:,}'.format(int(intervalos_ls[i]))) + " Li: " + str('{:,}'.format(int(intervalos_li[i])))
  plt.text(270, -100000, v_text, size=20)
  #legend.get_frame().set_alpha(0.5)

  for spine in ('top', 'right', 'bottom', 'left'):
      ax.spines[spine].set_visible(False)
  plt.savefig("figs/"+"SIR_ciudad_"+str(i)+".jpg", bbox_inches='tight')
  print('Beta:',round(valores[i][0],2), '; Gamma:', round(valores[i][1],2), '; Población:', '{:,}'.format(valores[i][2]), '; Ciudad:', valores[i][3])
  plt.show()

## Definición modelo 2 para sacar los suceptibles
def modelo2(beta, gamma, N, ciudad):
  # valores iniciales infectados (I0) y personas que se recuperan (R0)
  I0, R0 = 1,0
  # población suceptible
  S0 = N - I0 - R0
  # puntos en la gráfica
  t = np.linspace(0, 360, 360)
  # The SIR model differential equations.
  def deriv(y, t, N, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I / N
    dIdt = beta * S * I / N - gamma * I
    dRdt = gamma * I
    return dSdt, dIdt, dRdt
  # Vector de las condiciones iniciales
  y0 = S0, I0, R0
  # Resolver el sistema de ecuaciones diferenciales, en la secuencia de días que ya definimos
  ret = odeint(deriv, y0, t, args=(N, beta, gamma))
  S, I, R = ret.T
  return (S)

y_pred_med_s = modelo2(*valores[0])
y_pred_bog_s = modelo2(*valores[1])
y_pred_cal_s = modelo2(*valores[2])
y_pred_car_s = modelo2(*valores[3])
y_pred_bar_s = modelo2(*valores[4])

## Definición modelo 3 para sacar los recuperados
def modelo3(beta, gamma, N, ciudad):
  # valores iniciales infectados (I0) y personas que se recuperan (R0)
  I0, R0 = 1,0
  # población suceptible
  S0 = N - I0 - R0
  # puntos en la gráfica
  t = np.linspace(0, 360, 360)
  # The SIR model differential equations.
  def deriv(y, t, N, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I / N
    dIdt = beta * S * I / N - gamma * I
    dRdt = gamma * I
    return dSdt, dIdt, dRdt
  # Vector de las condiciones iniciales
  y0 = S0, I0, R0
  # Resolver el sistema de ecuaciones diferenciales, en la secuencia de días que ya definimos
  ret = odeint(deriv, y0, t, args=(N, beta, gamma))
  S, I, R = ret.T
  return (R)

y_pred_med_r = modelo3(*valores[0])
y_pred_bog_r = modelo3(*valores[1])
y_pred_cal_r = modelo3(*valores[2])
y_pred_car_r = modelo3(*valores[3])
y_pred_bar_r = modelo3(*valores[4])

"""###Generación de DF resumen para html modelo SIR"""

from pandas import DataFrame
#your_list = ['item1', 'item2', 'item3',...]
#df = DataFrame (your_list,columns=['Column_Name'])
#c_digo_divipola.isin(['05001'])]
#df.assign(Price=Price)
#df_concat_4_med['tasa_contagio'] = df_concat_4_med.nuevos_contagios / df_concat_4_med.casos_activos.shift(1)
y_pronostico_sir_med = DataFrame(y_pred_med, columns=['Infectados'])
y_pronostico_sir_bog = DataFrame(y_pred_bog, columns=['Infectados'])
y_pronostico_sir_cal = DataFrame(y_pred_cal, columns=['Infectados'])
y_pronostico_sir_car = DataFrame(y_pred_car, columns=['Infectados'])
y_pronostico_sir_bar = DataFrame(y_pred_bar, columns=['Infectados'])

#y_pronostico_sir_med['c_digo_divipola'] = '05011'

y_pronostico_sir_med = y_pronostico_sir_med.assign(Recuperados_y_Fallecidos = y_pred_med_r)
y_pronostico_sir_med = y_pronostico_sir_med.assign(Suceptibles = y_pred_med_s)
y_pronostico_sir_med['Nuevos_Activos'] = y_pronostico_sir_med.Infectados - y_pronostico_sir_med.Infectados.shift(1)
y_pronostico_sir_med['Nuevos_recuperados'] = y_pronostico_sir_med.Infectados.shift(1) * media_recuperacion_med
y_pronostico_sir_med['Nuevos_fallecidos'] = y_pronostico_sir_med.Recuperados_y_Fallecidos - y_pronostico_sir_med.Nuevos_recuperados
y_pronostico_sir_med['Total_Activos'] = poblacion_med - y_pronostico_sir_med.Suceptibles 
y_pronostico_sir_med['c_digo_divipola'] = '05011' 

y_pronostico_sir_bog = y_pronostico_sir_bog.assign(Recuperados_y_Fallecidos = y_pred_bog_r)
y_pronostico_sir_bog = y_pronostico_sir_bog.assign(Suceptibles = y_pred_bog_s)
y_pronostico_sir_bog['Nuevos_Activos'] = y_pronostico_sir_bog.Infectados - y_pronostico_sir_bog.Infectados.shift(1)
y_pronostico_sir_bog['Nuevos_recuperados'] = y_pronostico_sir_bog.Infectados.shift(1) * media_recuperacion_bog
y_pronostico_sir_bog['Nuevos_fallecidos'] = y_pronostico_sir_bog.Recuperados_y_Fallecidos - y_pronostico_sir_bog.Nuevos_recuperados
y_pronostico_sir_bog['Total_Activos'] = poblacion_bog - y_pronostico_sir_bog.Suceptibles 
y_pronostico_sir_bog['c_digo_divipola'] = '11001' 

y_pronostico_sir_cal = y_pronostico_sir_cal.assign(Recuperados_y_Fallecidos = y_pred_cal_r)
y_pronostico_sir_cal = y_pronostico_sir_cal.assign(Suceptibles = y_pred_cal_s)
y_pronostico_sir_cal['Nuevos_Activos'] = y_pronostico_sir_cal.Infectados - y_pronostico_sir_cal.Infectados.shift(1)
y_pronostico_sir_cal['Nuevos_recuperados'] = y_pronostico_sir_cal.Infectados.shift(1) * media_recuperacion_cal
y_pronostico_sir_cal['Nuevos_fallecidos'] = y_pronostico_sir_cal.Recuperados_y_Fallecidos - y_pronostico_sir_cal.Nuevos_recuperados
y_pronostico_sir_cal['Total_Activos'] = poblacion_cal - y_pronostico_sir_cal.Suceptibles 
y_pronostico_sir_cal['c_digo_divipola'] = '76001' 

y_pronostico_sir_car = y_pronostico_sir_car.assign(Recuperados_y_Fallecidos = y_pred_car_r)
y_pronostico_sir_car = y_pronostico_sir_car.assign(Suceptibles = y_pred_car_s)
y_pronostico_sir_car['Nuevos_Activos'] = y_pronostico_sir_car.Infectados - y_pronostico_sir_car.Infectados.shift(1)
y_pronostico_sir_car['Nuevos_recuperados'] = y_pronostico_sir_car.Infectados.shift(1) * media_recuperacion_car
y_pronostico_sir_car['Nuevos_fallecidos'] = y_pronostico_sir_car.Recuperados_y_Fallecidos - y_pronostico_sir_car.Nuevos_recuperados
y_pronostico_sir_car['Total_Activos'] = poblacion_car - y_pronostico_sir_car.Suceptibles 
y_pronostico_sir_car['c_digo_divipola'] = '13001' 

y_pronostico_sir_bar = y_pronostico_sir_bar.assign(Recuperados_y_Fallecidos = y_pred_bar_r)
y_pronostico_sir_bar = y_pronostico_sir_bar.assign(Suceptibles = y_pred_bar_s)
y_pronostico_sir_bar['Nuevos_Activos'] = y_pronostico_sir_bar.Infectados - y_pronostico_sir_bar.Infectados.shift(1)
y_pronostico_sir_bar['Nuevos_recuperados'] = y_pronostico_sir_bar.Infectados.shift(1) * media_recuperacion_bar
y_pronostico_sir_bar['Nuevos_fallecidos'] = y_pronostico_sir_bar.Recuperados_y_Fallecidos - y_pronostico_sir_bar.Nuevos_recuperados
y_pronostico_sir_bar['Total_Activos'] = poblacion_bar - y_pronostico_sir_bar.Suceptibles 
y_pronostico_sir_bar['c_digo_divipola'] = '08001' 

y_pronostico_sir = pd.concat([y_pronostico_sir_med, 
                              y_pronostico_sir_bog,
                              y_pronostico_sir_cal,
                              y_pronostico_sir_car,
                              y_pronostico_sir_bar],
                             axis=0)  

columnas_casteo = ['Infectados', 'Recuperados_y_Fallecidos', 'Suceptibles', 'Nuevos_Activos', 'Nuevos_recuperados', 'Nuevos_fallecidos', 'Total_Activos']
y_pronostico_sir[columnas_casteo] = y_pronostico_sir[columnas_casteo].apply(np.int64)

y_pronostico_sir
#df_concat_5 =pd.concat([df_concat_4_med, df_concat_4_bog, df_concat_4_cal, df_concat_4_car, df_concat_4_bar], axis=0)
#
#

"""### HTML SIR"""

y_pronostico_sir_med['dias'] =  np.array(range(360))
y_pronostico_sir_bog['dias'] =  np.array(range(360))
y_pronostico_sir_cal['dias'] =  np.array(range(360))
y_pronostico_sir_car['dias'] =  np.array(range(360))
y_pronostico_sir_bar['dias'] =  np.array(range(360))

#crear columna con el campo de fecha
def generar_dias_calendario_med(row):
    x = int(row["dias"])
    if x < len(df_concat_4_med):
      return (date.today()-(timedelta(days=len(df_concat_4_med)-x)))
    elif x >= len(df_concat_4_med):
      return (date.today()+(timedelta(days=x-len(df_concat_4_med))))
    else:
      return x


def generar_dias_calendario_bog(row):
    x = int(row["dias"])
    if x < len(df_concat_4_bog):
      return (date.today()-(timedelta(days=len(df_concat_4_bog)-x)))
    elif x >= len(df_concat_4_bog):
      return (date.today()+(timedelta(days=x-len(df_concat_4_bog))))
    else:
      return x

def generar_dias_calendario_cal(row):
    x = int(row["dias"])
    if x < len(df_concat_4_cal):
      return (date.today()-(timedelta(days=len(df_concat_4_cal)-x)))
    elif x >= len(df_concat_4_cal):
      return (date.today()+(timedelta(days=x-len(df_concat_4_cal))))
    else:
      return x

def generar_dias_calendario_car(row):
    x = int(row["dias"])
    if x < len(df_concat_4_car):
      return (date.today()-(timedelta(days=len(df_concat_4_car)-x)))
    elif x >= len(df_concat_4_car):
      return (date.today()+(timedelta(days=x-len(df_concat_4_car))))
    else:
      return x

def generar_dias_calendario_bar(row):
    x = int(row["dias"])
    if x < len(df_concat_4_bar):
      return (date.today()-(timedelta(days=len(df_concat_4_bar)-x)))
    elif x >= len(df_concat_4_bar):
      return (date.today()+(timedelta(days=x-len(df_concat_4_bar))))
    else:
      return x

y_pronostico_sir_med['fecha'] = y_pronostico_sir_med.apply(generar_dias_calendario_med, axis=1)
y_pronostico_sir_bog['fecha'] = y_pronostico_sir_bog.apply(generar_dias_calendario_bog, axis=1)
y_pronostico_sir_cal['fecha'] = y_pronostico_sir_cal.apply(generar_dias_calendario_cal, axis=1)
y_pronostico_sir_car['fecha'] = y_pronostico_sir_car.apply(generar_dias_calendario_car, axis=1)
y_pronostico_sir_bar['fecha'] = y_pronostico_sir_bar.apply(generar_dias_calendario_bar, axis=1)

y_pronostico_sir_med = y_pronostico_sir_med[y_pronostico_sir_med.fecha > date.today()]
y_pronostico_sir_bog = y_pronostico_sir_bog[y_pronostico_sir_bog.fecha > date.today()]
y_pronostico_sir_cal = y_pronostico_sir_cal[y_pronostico_sir_cal.fecha > date.today()]
y_pronostico_sir_car = y_pronostico_sir_car[y_pronostico_sir_car.fecha > date.today()]
y_pronostico_sir_bar = y_pronostico_sir_bar[y_pronostico_sir_bar.fecha > date.today()]

columnas_casteo = ['Infectados', 'Recuperados_y_Fallecidos', 'Suceptibles', 'Nuevos_Activos', 'Nuevos_recuperados', 'Nuevos_fallecidos', 'Total_Activos']
y_pronostico_sir_med[columnas_casteo] = y_pronostico_sir_med[columnas_casteo].apply(np.int64)
y_pronostico_sir_bog[columnas_casteo] = y_pronostico_sir_bog[columnas_casteo].apply(np.int64)
y_pronostico_sir_cal[columnas_casteo] = y_pronostico_sir_cal[columnas_casteo].apply(np.int64)
y_pronostico_sir_car[columnas_casteo] = y_pronostico_sir_car[columnas_casteo].apply(np.int64)
y_pronostico_sir_bar[columnas_casteo] = y_pronostico_sir_bar[columnas_casteo].apply(np.int64)

html_sir_med = y_pronostico_sir_med.to_html()
with open("file_sir_med.html", "w") as file:
    file.write(html_sir_med)

html_sir_bog = y_pronostico_sir_bog.to_html()
with open("file_sir_bog.html", "w") as file:
    file.write(html_sir_bog)

html_sir_cal = y_pronostico_sir_cal.to_html()
with open("file_sir_cal.html", "w") as file:
    file.write(html_sir_cal)

html_sir_car = y_pronostico_sir_car.to_html()
with open("file_sir_car.html", "w") as file:
    file.write(html_sir_car)

html_sir_bar = y_pronostico_sir_bar.to_html()
with open("file_sir_bar.html", "w") as file:
    file.write(html_sir_bar)

"""###Validación Modelo SIR con dataset de prueba"""

y_pred_med = modelo(*valores[0])
y_pred_bog = modelo(*valores[1])
y_pred_cal = modelo(*valores[2])
y_pred_car = modelo(*valores[3])
y_pred_bar = modelo(*valores[4])

array_to_df_med = pd.DataFrame(y_pred_med)
array_to_df_bog = pd.DataFrame(y_pred_bog)
array_to_df_cal = pd.DataFrame(y_pred_cal)
array_to_df_car = pd.DataFrame(y_pred_car)
array_to_df_bar = pd.DataFrame(y_pred_bar)

array_to_df_med.reset_index(drop=True, inplace=True)
array_to_df_bog.reset_index(drop=True, inplace=True)
array_to_df_cal.reset_index(drop=True, inplace=True)
array_to_df_car.reset_index(drop=True, inplace=True)
array_to_df_bar.reset_index(drop=True, inplace=True)

y_pred_med2 = array_to_df_med.values
y_pred_bog2 = array_to_df_bog.values
y_pred_cal2 = array_to_df_cal.values
y_pred_car2 = array_to_df_car.values
y_pred_bar2 = array_to_df_bar.values


for i in range(len(y_true_med)-5, len(y_true_med)):
  print("Medellín: día {}".format(i),"Pred {}".format(int(y_pred_med2[i])), "Real {}".format(int(y_true_med[i])), "MAPE {}".format("%.2f" %float((abs(int(y_pred_med2[i])-int(y_true_med[i]))/int(y_true_med[i]))*100)), "%")
print('')
for i in range(len(y_true_bog)-5, len(y_true_bog)):
  print("Bogotá: día {}".format(i),"Pred {}".format(int(y_pred_bog2[i])), "Real {}".format(int(y_true_bog[i])), "MAPE {}".format("%.2f" %float((abs(int(y_pred_bog2[i])-int(y_true_bog[i]))/int(y_true_bog[i]))*100)), "%")
print('')
for i in range(len(y_true_cal)-5, len(y_true_cal)):
  print("Cali: día {}".format(i),"Pred {}".format(int(y_pred_cal2[i])), "Real {}".format(int(y_true_cal[i])), "MAPE {}".format("%.2f" %float((abs(int(y_pred_cal2[i])-int(y_true_cal[i]))/int(y_true_cal[i]))*100)), "%")
print('')
for i in range(len(y_true_car)-5, len(y_true_car)):
  print("Cartagena: día {}".format(i),"Pred {}".format(int(y_pred_car2[i])), "Real {}".format(int(y_true_car[i])), "MAPE {}".format("%.2f" %float((abs(int(y_pred_car2[i])-int(y_true_car[i]))/int(y_true_car[i]))*100)), "%")
print('')
for i in range(len(y_true_bar)-5, len(y_true_bar)):
  print("Barranquilla: día {}".format(i),"Pred {}".format(int(y_pred_bar2[i])), "Real {}".format(int(y_true_bar[i])), "MAPE {}".format("%.2f" %float((abs(int(y_pred_bar2[i])-int(y_true_bar[i]))/int(y_true_bar[i]))*100)), "%")

"""##Modelo Regresión Logística

Habiendo construido el Modelo SIR para el mediano plazo , adoptamos la regresión logística como análisis principal en la modelación a corto plazo soportado en las caracteristicas comportamentales de la pandemia en la que se detalla claramente un crecimiento exponencial y considerando que se adapta en buena forma a la función en mención, este es un modelo que permite evidenciar en que momento se dará el pico máximo del Covid – 19 en cada una de las ciudades seleccionadas, como característica principal del modelo esta la saturación que considera como factor preponderante al entenderse que la población es finita.
Por lo anterior optamos por utilizar la función curve_fit de la librería scipy aplicada junto con la función logística para hallar la curva que más se parece a cada ciudad y de esa forma hallar el pronóstico de los casos de contagios.

Enfatizando que el modelo de regresión logística por su caracteristica de converger en un valor máximo, se descartó para realizar pronósticos de mediano y largo plazo, dado que el fenómeno epidemiológico del Covid 19 se representá por una curva que alcanza su valor máximo de contagio y comienza a reducirse hasta su mínima expresión.

###Regresión logística Infectados
"""

#Grafica las curvas actuales
ax = sns.lineplot(x=df_concat_5_train['fecha'], y=df_concat_5_train['acumulado_contagios'],data=df_concat_5_train,hue=df_concat_5_train['NOMBRE_MPIO'],linewidth=2)
ax.tick_params(axis="x", labelsize=15)
ax.tick_params(axis="y", labelsize=15)
plt.legend(prop={'size': 20})
plt.xlabel('fecha', fontsize=20)
plt.ylabel('CASOS', fontsize=20)
plt.show()

#Genera acumulado de casos
ccaa=df_concat_5_train["NOMBRE_MPIO"].unique()
ccaadict={}
for i in ccaa:
  ccaadict[i]={}
  ccaadict[i]["covid19_ts"]=df_concat_5_train[df_concat_5_train["NOMBRE_MPIO"]==i][["acumulado_contagios","fecha"]]
  ccaadict[i]["covid19_ts"]=ccaadict[i]["covid19_ts"].set_index("fecha")
  ccaadict[i]["covid19_ts_casos_notnull"]=df_concat_5_train[(df_concat_5_train["acumulado_contagios"]!= 0)&(df_concat_5_train["NOMBRE_MPIO"]==i)]
  ccaadict[i]["covid19_ts_casos_notnull"]=ccaadict[i]["covid19_ts_casos_notnull"].set_index("fecha")
ccaadict

#Lista de ciudades
top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()

#Definición del modelo: Función logístico
def func_logistico(x,a,b,c):
    return c/(1+np.exp(-(x-b)/a))
timeserieschosen="covid19_ts_casos_notnull"
polinomios_logistico={}
for comunidad in top5ccaa:
    longitud=ccaadict[comunidad][timeserieschosen].index.size
    polinomios_logistico[comunidad]= curve_fit(func_logistico,list(range(longitud)),ccaadict[comunidad][timeserieschosen]['acumulado_contagios']+ np.random.normal(size=longitud),maxfev=10000)

for i in top5ccaa:

  if i == "Bogotá, D.C.":
    a = 0
  elif i == "Medellín":
    a = 1
  elif i == "Cali":
    a = 2
  elif i == "Barranquilla":
    a = 3
  else:
    a = 4


  #Graficar real vs proyectado
  top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()
  comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
  longitud=ccaadict[comunidad][timeserieschosen].index.size 
  #Intervalos de confianza
  miu = np.mean(func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0]))
  cuadrado = ((func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])) - miu)**2
  suma = sum(cuadrado)
  div = suma / len(cuadrado)
  desviacion_estandar = div ** (1/2)
  li = miu - 1.96*(desviacion_estandar/((len(cuadrado))**(1/2)))
  ls = miu + 1.96*(desviacion_estandar/((len(cuadrado))**(1/2)))

  plt.rc('figure', figsize=(35, 12))
  plt.plot(np.linspace(0,longitud*2,longitud*2),func_logistico(np.linspace(0,longitud*2,longitud*2),*polinomios_logistico[comunidad][0])+ (ls - miu),linewidth=4)
  plt.plot(np.linspace(0,longitud*2,longitud*2),func_logistico(np.linspace(0,longitud*2,longitud*2),*polinomios_logistico[comunidad][0]),linewidth=4)
  plt.plot(np.linspace(0,longitud*2,longitud*2),func_logistico(np.linspace(0,longitud*2,longitud*2),*polinomios_logistico[comunidad][0])-(miu - li),linewidth=4)
  plt.plot(range(longitud),ccaadict[comunidad][timeserieschosen]["acumulado_contagios"],"o",color="red",markeredgewidth=3)
  plt.legend(["Límite Superior", "Logistic Model", "Límite inferior", "Real Data"], prop={'size': 20})
  plt.xlabel('DÍAS', fontsize=20)
  plt.ylabel('CASOS', fontsize=20)
  plt.xticks(fontsize=15)
  plt.yticks(fontsize=15)
  

  #plt.text(200, miu, r'$\mu=ls\ \sigma=15$', size=20)
  v_text = "Ls: " + str('{:,}'.format(int(ls))) + "; Li: " + str('{:,}'.format(int(li)) + "; Ciudad: " +top5ccaa[a])
  plt.text(200, miu-0.1*miu, v_text, size=20)
  plt.savefig('figs/' + top5ccaa[a] + '.png')
  plt.show()
  #plt.savefig("prueba.jpg", bbox_inches='tight')
  #fig = data.plot.bar(y=col).get_figure().savefig('figs/' + top5ccaa[i] + '.png')

for i in top5ccaa:
  if i == "Bogotá, D.C.":
    a = 0
  elif i == "Medellín":
    a = 1
  elif i == "Cali":
    a = 2
  elif i == "Barranquilla":
    a = 3
  else:
    a = 4
  print(i)
  if a == 0:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size
    y_proyec_log_b_0 = func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_b_0_df = DataFrame(y_proyec_log_b_0, columns=['Infectados'])
    y_proyec_log_b_0_df ['ciudad'] = i
  elif a == 1:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size    
    y_proyec_log_b_1 = func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_b_1_df = DataFrame(y_proyec_log_b_1, columns=['Infectados'])
    y_proyec_log_b_1_df ['ciudad'] = i
  elif a == 2:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size    
    y_proyec_log_b_2 = func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_b_2_df = DataFrame(y_proyec_log_b_2, columns=['Infectados'])
    y_proyec_log_b_2_df ['ciudad'] = i
  elif a == 3:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size
    y_proyec_log_b_3 = func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_b_3_df = DataFrame(y_proyec_log_b_3, columns=['Infectados'])
    y_proyec_log_b_3_df ['ciudad'] = i
  elif a == 4:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size
    y_proyec_log_b_4 = func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_b_4_df = DataFrame(y_proyec_log_b_4, columns=['Infectados'])
    y_proyec_log_b_4_df ['ciudad'] = i

y_pronostico_log_infectados = pd.concat([y_proyec_log_b_0_df,
                                         y_proyec_log_b_1_df,
                                         y_proyec_log_b_2_df,
                                         y_proyec_log_b_3_df,
                                         y_proyec_log_b_4_df],
                                        axis=0)

y_pronostico_log_infectados

#Quitar
#Para texto flotante
v_text = "Ls: " + str('{:,}'.format(int(ls))) + " Li: " + str('{:,}'.format(int(li)))
v_text

#'{:,}'.format(value)
#'{:n}'.format(value)

#"MAPE {}".format("%.2f" %float((abs(int(y_pred_bar2[i])-int(y_true_bar[i]))/int(y_true_bar[i]))*100)), "%")

#CÁLCULO DEL ERROR CUADRÁTICO MEDIO
mse={}
for key in polinomios_logistico.keys():
  longitud=ccaadict[key][timeserieschosen].index.size 
  mse[key]=mean_squared_error(ccaadict[key][timeserieschosen]["acumulado_contagios"],
                              func_logistico(range(longitud),
                                             *polinomios_logistico[key][0]))
mse

#PLOT DATOS FUNCIÓN LOGÍSTICA TODAS LAS CIUDADES
for i in polinomios_logistico:
  plt.plot(np.linspace(0,150,1000),func_logistico(np.linspace(0,100,1000),*polinomios_logistico[i][0]))
  plt.legend(polinomios_logistico.keys(), prop={'size': 20})
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.xlabel('DÍAS', fontsize=20)
plt.ylabel('CASOS', fontsize=20)
plt.show()

#Puntos de estabilización de los contágios, en días
regimenpermanente={}
for i in polinomios_logistico.keys():
  regimenpermanente[i]=polinomios_logistico[i][0][2]*0.99

daysregimenpermanente={}
for i in polinomios_logistico.keys():
  daysregimenpermanente[i]=int(fsolve(lambda x : func_logistico(x,*polinomios_logistico[i][0]) - int(regimenpermanente[i]),polinomios_logistico[i][0][1]))
regimenpermanente
daysregimenpermanente

#Puntos de estabilización de los contágios, en fechas
import datetime
fecharegimenpermanente={}
for i in daysregimenpermanente.keys():
  fecharegimenpermanente[i] = ccaadict[i][timeserieschosen].index[0] + datetime.timedelta(days=daysregimenpermanente[i])
fecharegimenpermanente

"""###Intervalos de confianza regresión logística"""

#Intervalos de confianza - Infectados

miu = np.mean(func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0]))
cuadrado = ((func_logistico(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])) - miu)**2
suma = sum(cuadrado)
div = suma / len(cuadrado)
desviacion_estandar = div ** (1/2)
li = miu - 1.96*(desviacion_estandar/((len(cuadrado))**(1/2)))
ls = miu + 1.96*(desviacion_estandar/((len(cuadrado))**(1/2)))
print('Desviación estandar: ', round(desviacion_estandar,2))
print("Límite Inferior: ", '{:,}'.format(round(li,2)))
print("Límite Superior: ", '{:,}'.format(round(ls,2)))
print("Media; ", '{:,}'.format(round(miu,2)))
print("Diferencia media y límite inferior:", round(miu - li,2))
print("Diferencia límite superior y media:", round(ls - miu,2))

"""### Regresión logística Fallecidos"""

#Grafica las curvas actuales
ax = sns.lineplot(x=df_concat_5_train['fecha'], y=df_concat_5_train['acumulado_fallecidos'],data=df_concat_5_train,hue=df_concat_5_train['NOMBRE_MPIO'],linewidth=2)
ax.tick_params(axis="x", labelsize=15)
ax.tick_params(axis="y", labelsize=15)
plt.legend(prop={'size': 20})
plt.xlabel('fecha', fontsize=20)
plt.ylabel('CASOS', fontsize=20)
plt.show()

#genera acumulado de casos
ccaa=df_concat_5_train["NOMBRE_MPIO"].unique()
ccaadict={}
for i in ccaa:
  ccaadict[i]={}
  ccaadict[i]["covid19_ts"]=df_concat_5_train[df_concat_5_train["NOMBRE_MPIO"]==i][["acumulado_fallecidos","fecha"]]
  ccaadict[i]["covid19_ts"]=ccaadict[i]["covid19_ts"].set_index("fecha")
  ccaadict[i]["covid19_ts_casos_notnull"]=df_concat_5_train[(df_concat_5_train["acumulado_fallecidos"]!= 0)&(df_concat_5_train["NOMBRE_MPIO"]==i)]
  ccaadict[i]["covid19_ts_casos_notnull"]=ccaadict[i]["covid19_ts_casos_notnull"].set_index("fecha")
ccaadict

top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_fallecidos"], ascending=False)[0:5].index.tolist()

#Definición del modelo: Función logístico
def func_logistico2(x,a,b,c):
    return c/(1+np.exp(-(x-b)/a))
timeserieschosen="covid19_ts_casos_notnull"
polinomios_logistico={}
for comunidad in top5ccaa:
    longitud=ccaadict[comunidad][timeserieschosen].index.size
    polinomios_logistico[comunidad]= curve_fit(func_logistico,list(range(longitud)),ccaadict[comunidad][timeserieschosen]['acumulado_fallecidos']+ np.random.normal(size=longitud),maxfev=10000)

for i in top5ccaa:
  if i == "Bogotá, D.C.":
    a = 0
  elif i == "Medellín":
    a = 1
  elif i == "Cali":
    a = 2
  elif i == "Barranquilla":
    a = 3
  else:
    a = 4
  print(i)
  if a == 0:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_fallecidos"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size    
    y_proyec_log_a_0 = func_logistico2(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_a_0_df = DataFrame(y_proyec_log_a_0, columns=['Fallecidos'])
    y_proyec_log_a_0_df ['ciudad'] = i
  elif a == 1:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_fallecidos"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_a_1 = func_logistico2(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_a_1_df = DataFrame(y_proyec_log_a_1, columns=['Fallecidos'])
    y_proyec_log_a_1_df ['ciudad'] = i
  elif a == 2:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_fallecidos"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_a_2 = func_logistico2(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_a_2_df = DataFrame(y_proyec_log_a_2, columns=['Fallecidos'])
    y_proyec_log_a_2_df ['ciudad'] = i
  elif a == 3:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_fallecidos"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_a_3 = func_logistico2(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_a_3_df = DataFrame(y_proyec_log_a_3, columns=['Fallecidos'])
    y_proyec_log_a_3_df ['ciudad'] = i
  elif a == 4:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_fallecidos"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_a_4 = func_logistico2(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_a_4_df = DataFrame(y_proyec_log_a_4, columns=['Fallecidos'])
    y_proyec_log_a_4_df ['ciudad'] = i

y_pronostico_log_fallecidos = pd.concat([y_proyec_log_a_0_df,
                                         y_proyec_log_a_1_df,
                                         y_proyec_log_a_2_df,
                                         y_proyec_log_a_3_df,
                                         y_proyec_log_a_4_df],
                                        axis=0)
y_pronostico_log_fallecidos

"""### Regresión logística Recuperados"""

#Grafica las curvas actuales
ax = sns.lineplot(x=df_concat_5_train['fecha'], y=df_concat_5_train['acumulado_recuperados'],data=df_concat_5_train,hue=df_concat_5_train['NOMBRE_MPIO'],linewidth=2)
ax.tick_params(axis="x", labelsize=15)
ax.tick_params(axis="y", labelsize=15)
plt.legend(prop={'size': 20})
plt.xlabel('fecha', fontsize=20)
plt.ylabel('CASOS', fontsize=20)
plt.show()

#genera acumulado de casos
ccaa=df_concat_5_train["NOMBRE_MPIO"].unique()
ccaadict={}
for i in ccaa:
  ccaadict[i]={}
  ccaadict[i]["covid19_ts"]=df_concat_5_train[df_concat_5_train["NOMBRE_MPIO"]==i][["acumulado_recuperados","fecha"]]
  ccaadict[i]["covid19_ts"]=ccaadict[i]["covid19_ts"].set_index("fecha")
  ccaadict[i]["covid19_ts_casos_notnull"]=df_concat_5_train[(df_concat_5_train["acumulado_recuperados"]!= 0)&(df_concat_5_train["NOMBRE_MPIO"]==i)]
  ccaadict[i]["covid19_ts_casos_notnull"]=ccaadict[i]["covid19_ts_casos_notnull"].set_index("fecha")
ccaadict

top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_recuperados"], ascending=False)[0:5].index.tolist()

#Definición del modelo: Función logístico
def func_logistico3(x,a,b,c):
    return c/(1+np.exp(-(x-b)/a))
timeserieschosen="covid19_ts_casos_notnull"
polinomios_logistico={}
for comunidad in top5ccaa:
    longitud=ccaadict[comunidad][timeserieschosen].index.size
    polinomios_logistico[comunidad]= curve_fit(func_logistico,list(range(longitud)),ccaadict[comunidad][timeserieschosen]['acumulado_recuperados']+ np.random.normal(size=longitud),maxfev=10000)

for i in top5ccaa:
  if i == "Bogotá, D.C.":
    a = 0
  elif i == "Medellín":
    a = 1
  elif i == "Cali":
    a = 2
  elif i == "Barranquilla":
    a = 3
  else:
    a = 4
  print(i)
  if a == 0:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_recuperados"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size    
    y_proyec_log_c_0 = func_logistico3(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_c_0_df = DataFrame(y_proyec_log_c_0, columns=['Recuperados'])
    y_proyec_log_c_0_df ['ciudad'] = i
  elif a == 1:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_recuperados"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_c_1 = func_logistico3(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_c_1_df = DataFrame(y_proyec_log_c_1, columns=['Recuperados'])
    y_proyec_log_c_1_df ['ciudad'] = i
  elif a == 2:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_recuperados"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_c_2 = func_logistico3(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_c_2_df = DataFrame(y_proyec_log_c_2, columns=['Recuperados'])
    y_proyec_log_c_2_df ['ciudad'] = i
  elif a == 3:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_recuperados"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_c_3 = func_logistico3(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_c_3_df = DataFrame(y_proyec_log_c_3, columns=['Recuperados'])
    y_proyec_log_c_3_df ['ciudad'] = i
  elif a == 4:
    top5ccaa=df_concat_5_train.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_recuperados"], ascending=False)[0:5].index.tolist()
    comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
    longitud=ccaadict[comunidad][timeserieschosen].index.size      
    y_proyec_log_c_4 = func_logistico3(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])
    y_proyec_log_c_4_df = DataFrame(y_proyec_log_c_4, columns=['Recuperados'])
    y_proyec_log_c_4_df ['ciudad'] = i

y_pronostico_log_recuperados = pd.concat([y_proyec_log_c_0_df,
                                          y_proyec_log_c_1_df,
                                          y_proyec_log_c_2_df,
                                          y_proyec_log_c_3_df,
                                          y_proyec_log_c_4_df],
                                         axis=0)
y_pronostico_log_recuperados

"""###Generación de DF resumen para html Proyección Logística"""

y_pronostico_log_concat2=y_pronostico_log_infectados.copy()

y_pronostico_log_concat2['Recuperados'] = y_pronostico_log_recuperados['Recuperados']
y_pronostico_log_concat2['Fallecidos'] = y_pronostico_log_fallecidos['Fallecidos']

y_pronostico_log_concat2_med = y_pronostico_log_concat2[y_pronostico_log_concat2.ciudad.isin(['Medellín'])]
y_pronostico_log_concat2_bog = y_pronostico_log_concat2[y_pronostico_log_concat2.ciudad.isin(['Bogotá, D.C.'])]
y_pronostico_log_concat2_cal = y_pronostico_log_concat2[y_pronostico_log_concat2.ciudad.isin(['Cali'])]
y_pronostico_log_concat2_car = y_pronostico_log_concat2[y_pronostico_log_concat2.ciudad.isin(['Barranquilla'])]
y_pronostico_log_concat2_bar = y_pronostico_log_concat2[y_pronostico_log_concat2.ciudad.isin(['Cartagena'])]

y_pronostico_log_concat2_med['Suceptibles'] = poblacion_med - y_pronostico_log_concat2_med.Infectados - y_pronostico_log_concat2_med.Recuperados - y_pronostico_log_concat2_med.Fallecidos 
y_pronostico_log_concat2_bog['Suceptibles'] = poblacion_bog - y_pronostico_log_concat2_bog.Infectados - y_pronostico_log_concat2_bog.Recuperados - y_pronostico_log_concat2_bog.Fallecidos 
y_pronostico_log_concat2_cal['Suceptibles'] = poblacion_cal - y_pronostico_log_concat2_cal.Infectados - y_pronostico_log_concat2_cal.Recuperados - y_pronostico_log_concat2_cal.Fallecidos
y_pronostico_log_concat2_car['Suceptibles'] = poblacion_car - y_pronostico_log_concat2_car.Infectados - y_pronostico_log_concat2_car.Recuperados - y_pronostico_log_concat2_car.Fallecidos
y_pronostico_log_concat2_bar['Suceptibles'] = poblacion_bar - y_pronostico_log_concat2_bar.Infectados - y_pronostico_log_concat2_bar.Recuperados - y_pronostico_log_concat2_bar.Fallecidos

y_pronostico_log_concat2_med['Nuevos_activos'] = y_pronostico_log_concat2_med.Infectados - y_pronostico_log_concat2_med.Infectados.shift(1)
y_pronostico_log_concat2_bog['Nuevos_activos'] = y_pronostico_log_concat2_bog.Infectados - y_pronostico_log_concat2_bog.Infectados.shift(1)
y_pronostico_log_concat2_cal['Nuevos_activos'] = y_pronostico_log_concat2_cal.Infectados - y_pronostico_log_concat2_cal.Infectados.shift(1)
y_pronostico_log_concat2_car['Nuevos_activos'] = y_pronostico_log_concat2_car.Infectados - y_pronostico_log_concat2_car.Infectados.shift(1)
y_pronostico_log_concat2_bar['Nuevos_activos'] = y_pronostico_log_concat2_bar.Infectados - y_pronostico_log_concat2_bar.Infectados.shift(1)

y_pronostico_log_concat2_med['Nuevos_recuperados'] = y_pronostico_log_concat2_med.Recuperados - y_pronostico_log_concat2_med.Recuperados.shift(1)
y_pronostico_log_concat2_bog['Nuevos_recuperados'] = y_pronostico_log_concat2_bog.Recuperados - y_pronostico_log_concat2_bog.Recuperados.shift(1)
y_pronostico_log_concat2_cal['Nuevos_recuperados'] = y_pronostico_log_concat2_cal.Recuperados - y_pronostico_log_concat2_cal.Recuperados.shift(1)
y_pronostico_log_concat2_car['Nuevos_recuperados'] = y_pronostico_log_concat2_car.Recuperados - y_pronostico_log_concat2_car.Recuperados.shift(1)
y_pronostico_log_concat2_bar['Nuevos_recuperados'] = y_pronostico_log_concat2_bar.Recuperados - y_pronostico_log_concat2_bar.Recuperados.shift(1)

y_pronostico_log_concat2_med['Nuevos_fallecidos'] = y_pronostico_log_concat2_med.Fallecidos - y_pronostico_log_concat2_med.Fallecidos.shift(1)
y_pronostico_log_concat2_bog['Nuevos_fallecidos'] = y_pronostico_log_concat2_bog.Fallecidos - y_pronostico_log_concat2_bog.Fallecidos.shift(1)
y_pronostico_log_concat2_cal['Nuevos_fallecidos'] = y_pronostico_log_concat2_cal.Fallecidos - y_pronostico_log_concat2_cal.Fallecidos.shift(1)
y_pronostico_log_concat2_car['Nuevos_fallecidos'] = y_pronostico_log_concat2_car.Fallecidos - y_pronostico_log_concat2_car.Fallecidos.shift(1)
y_pronostico_log_concat2_bar['Nuevos_fallecidos'] = y_pronostico_log_concat2_bar.Fallecidos - y_pronostico_log_concat2_bar.Fallecidos.shift(1)

y_pronostico_log_concat2_med['Total_activos'] = y_pronostico_log_concat2_med.Infectados + y_pronostico_log_concat2_med.Recuperados + y_pronostico_log_concat2_med.Fallecidos
y_pronostico_log_concat2_bog['Total_activos'] = y_pronostico_log_concat2_bog.Infectados + y_pronostico_log_concat2_bog.Recuperados + y_pronostico_log_concat2_bog.Fallecidos
y_pronostico_log_concat2_cal['Total_activos'] = y_pronostico_log_concat2_cal.Infectados + y_pronostico_log_concat2_cal.Recuperados + y_pronostico_log_concat2_cal.Fallecidos
y_pronostico_log_concat2_car['Total_activos'] = y_pronostico_log_concat2_car.Infectados + y_pronostico_log_concat2_car.Recuperados + y_pronostico_log_concat2_car.Fallecidos
y_pronostico_log_concat2_bar['Total_activos'] = y_pronostico_log_concat2_bar.Infectados + y_pronostico_log_concat2_bar.Recuperados + y_pronostico_log_concat2_bar.Fallecidos

y_pronostico_log_concat2_med['c_digo_divipola'] = '05001'
y_pronostico_log_concat2_bog['c_digo_divipola'] = '11001'
y_pronostico_log_concat2_cal['c_digo_divipola'] = '76001'
y_pronostico_log_concat2_car['c_digo_divipola'] = '13001'
y_pronostico_log_concat2_bar['c_digo_divipola'] = '08001'

y_pronostico_log_completo = pd.concat([y_pronostico_log_concat2_med, 
                              y_pronostico_log_concat2_bog,
                              y_pronostico_log_concat2_cal,
                              y_pronostico_log_concat2_car,
                              y_pronostico_log_concat2_bar],
                              axis=0) 


columnas_casteo = ['Infectados', 'Recuperados', 'Fallecidos', 'Suceptibles', 'Nuevos_activos', 'Nuevos_recuperados', 'Nuevos_fallecidos', 'Total_activos' ]
y_pronostico_log_completo[columnas_casteo] = y_pronostico_log_completo[columnas_casteo].apply(np.int64)


#columnas_casteo = ['Infectados', 'Recuperados_y_Fallecidos', 'Suceptibles', 'Nuevos_Activos', 'Nuevos_recuperados', 'Nuevos_fallecidos', 'Total_Activos']
#y_pronostico_sir[columnas_casteo] = y_pronostico_sir2[columnas_casteo].apply(np.int64)
#df_concat_5_train_med = df_concat_5_train[df_concat_5_train.c_digo_divipola.isin(['05001'])]
print(len(y_pronostico_log_concat2))
y_pronostico_log_completo

"""### HTML REGRESIÓN LOGISTÍCA"""

y_pronostico_log_concat2_med['dias'] =  np.array(range(10))
y_pronostico_log_concat2_bog['dias'] =  np.array(range(10))
y_pronostico_log_concat2_cal['dias'] =  np.array(range(10))
y_pronostico_log_concat2_car['dias'] =  np.array(range(10))
y_pronostico_log_concat2_bar['dias'] =  np.array(range(10))

#crear columna con el campo de fecha
def generar_dias_calendario_rl_med(row):
    x = int(row["dias"])
    if x >= 0:
      return (date.today()+(timedelta(days=int(row["dias"]))))
    else:
      return x

def generar_dias_calendario_rl_bog(row):
    x = int(row["dias"])
    if x >= 0:
      return (date.today()+(timedelta(days=int(row["dias"]))))
    else:
      return x

def generar_dias_calendario_rl_cal(row):
    x = int(row["dias"])
    if x >= 0:
      return (date.today()+(timedelta(days=int(row["dias"]))))
    else:
      return x

def generar_dias_calendario_rl_car(row):
    x = int(row["dias"])
    if x >= 0:
      return (date.today()+(timedelta(days=int(row["dias"]))))
    else:
      return x

def generar_dias_calendario_rl_bar(row):
    x = int(row["dias"])
    if x >= 0:
      return (date.today()+(timedelta(days=int(row["dias"]))))
    else:
      return x

y_pronostico_log_concat2_med['fecha'] = y_pronostico_log_concat2_med.apply(generar_dias_calendario_rl_med, axis=1)
y_pronostico_log_concat2_bog['fecha'] = y_pronostico_log_concat2_bar.apply(generar_dias_calendario_rl_bog, axis=1)
y_pronostico_log_concat2_cal['fecha'] = y_pronostico_log_concat2_cal.apply(generar_dias_calendario_rl_cal, axis=1)
y_pronostico_log_concat2_car['fecha'] = y_pronostico_log_concat2_car.apply(generar_dias_calendario_rl_car, axis=1)
y_pronostico_log_concat2_bar['fecha'] = y_pronostico_log_concat2_bar.apply(generar_dias_calendario_rl_bar, axis=1)

y_pronostico_log_concat2_med = y_pronostico_log_concat2_med[y_pronostico_log_concat2_med.fecha > date.today()]
y_pronostico_log_concat2_bog = y_pronostico_log_concat2_bog[y_pronostico_log_concat2_bog.fecha > date.today()]
y_pronostico_log_concat2_cal = y_pronostico_log_concat2_cal[y_pronostico_log_concat2_cal.fecha > date.today()]
y_pronostico_log_concat2_car = y_pronostico_log_concat2_car[y_pronostico_log_concat2_car.fecha > date.today()]
y_pronostico_log_concat2_bar = y_pronostico_log_concat2_bar[y_pronostico_log_concat2_bar.fecha > date.today()]

columnas_casteo = ['Infectados', 'Recuperados', 'Fallecidos', 'Suceptibles', 'Nuevos_activos', 'Nuevos_recuperados', 'Nuevos_fallecidos', 'Total_activos']
y_pronostico_log_concat2_med[columnas_casteo] = y_pronostico_log_concat2_med[columnas_casteo].apply(np.int64)
y_pronostico_log_concat2_bog[columnas_casteo] = y_pronostico_log_concat2_bog[columnas_casteo].apply(np.int64)
y_pronostico_log_concat2_cal[columnas_casteo] = y_pronostico_log_concat2_cal[columnas_casteo].apply(np.int64)
y_pronostico_log_concat2_car[columnas_casteo] = y_pronostico_log_concat2_car[columnas_casteo].apply(np.int64)
y_pronostico_log_concat2_bar[columnas_casteo] = y_pronostico_log_concat2_bar[columnas_casteo].apply(np.int64)

html_rl_med = y_pronostico_log_concat2_med.to_html()
with open("file_rl_med.html", "w") as file:
    file.write(html_rl_med)

html_rl_bog = y_pronostico_log_concat2_bog.to_html()
with open("file_rl_bog.html", "w") as file:
    file.write(html_rl_bog)

html_rl_cal = y_pronostico_log_concat2_cal.to_html()
with open("file_rl_cal.html", "w") as file:
    file.write(html_rl_cal)

html_rl_car = y_pronostico_log_concat2_car.to_html()
with open("file_rl_car.html", "w") as file:
    file.write(html_rl_car)

html_rl_bar = y_pronostico_log_concat2_bar.to_html()
with open("file_rl_bar.html", "w") as file:
    file.write(html_rl_bar)

"""###Validación Modelo de regresión logística con dataset de prueba"""

ccaa=df_concat_5_check["NOMBRE_MPIO"].unique()
ccaadict={}
for i in ccaa:
  ccaadict[i]={}
  ccaadict[i]["covid19_ts"]=df_concat_5_check[df_concat_5_check["NOMBRE_MPIO"]==i][["acumulado_contagios","fecha"]]
  ccaadict[i]["covid19_ts"]=ccaadict[i]["covid19_ts"].set_index("fecha")
  ccaadict[i]["covid19_ts_casos_notnull"]=df_concat_5_check[(df_concat_5_check["acumulado_contagios"]!= 0)&(df_concat_5_check["NOMBRE_MPIO"]==i)]
  ccaadict[i]["covid19_ts_casos_notnull"]=ccaadict[i]["covid19_ts_casos_notnull"].set_index("fecha")
ccaadict

top5ccaa=df_concat_5_check.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()

#Definición del modelo: Función logístico
def func_logistico9(x,a,b,c):
    return c/(1+np.exp(-(x-b)/a))
timeserieschosen="covid19_ts_casos_notnull"
polinomios_logistico9={}
for comunidad in top5ccaa:
    longitud=ccaadict[comunidad][timeserieschosen].index.size
    polinomios_logistico9[comunidad]= curve_fit(func_logistico9,list(range(longitud)),ccaadict[comunidad][timeserieschosen]['acumulado_contagios']+ np.random.normal(size=longitud),maxfev=10000)

for i in top5ccaa:

  if i == "Bogotá, D.C.":
    a = 0
  elif i == "Medellín":
    a = 1
  elif i == "Cali":
    a = 2
  elif i == "Barranquilla":
    a = 3
  else:
    a = 4


  #Graficar real vs proyectado
  top5ccaa=df_concat_5_check.groupby(["NOMBRE_MPIO"]).max().sort_values(by=["acumulado_contagios"], ascending=False)[0:5].index.tolist()
  comunidad = top5ccaa[a] #Para sacar las gráficas para el DashBoard                  
  longitud=ccaadict[comunidad][timeserieschosen].index.size 
  #Intervalos de confianza
  miu = np.mean(func_logistico9(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0]))
  cuadrado = ((func_logistico9(np.linspace(longitud,longitud+10,10),*polinomios_logistico[comunidad][0])) - miu)**2
  suma = sum(cuadrado)
  div = suma / len(cuadrado)
  desviacion_estandar = div ** (1/2)
  li = miu - 1.96*(desviacion_estandar/((len(cuadrado))**(1/2)))
  ls = miu + 1.96*(desviacion_estandar/((len(cuadrado))**(1/2)))

  #plt.rc('figure', figsize=(35, 12))
  #plt.plot(np.linspace(0,longitud*2,longitud*2),func_logistico2(np.linspace(0,longitud*2,longitud*2),*polinomios_logistico2[comunidad][0])+ (ls - miu),linewidth=4)
  #plt.plot(np.linspace(0,longitud,longitud),func_logistico9(np.linspace(0,longitud,longitud),*polinomios_logistico9[comunidad][0]),linewidth=4)
  y_predic_rl = func_logistico9(np.linspace(0,longitud,longitud),*polinomios_logistico9[comunidad][0])
  y_predic_rl = pd.Series(y_predic_rl)


  y_predic_rl_0 = y_predic_rl[0]
  y_predic_rl_1 = y_predic_rl[1]
  y_predic_rl_2 = y_predic_rl[2]


  y_real_rl = ccaadict[comunidad][timeserieschosen]["acumulado_contagios"]
  
  y_real_rl_0 = y_real_rl[0]
  y_real_rl_1 = y_real_rl[1]
  y_real_rl_2 = y_real_rl[2]
  
  
  #array_real_rl = [y_real_rl[0], y_real_rl[1], y_real_rl[2]]
  #print(array_real_rl)
  #for i in [1,2,3]:
  #mape_rl_0 = (abs(int(array_pred_rl[0]) - int(array_real_rl[0]))
  #fffff = int(array_pred_rl[0])
  #print(fffff)
  #mape_rl_1 = (abs(int(array_pred_rl[1]) - int(array_real_rl[1]))
  #mape_rl_2 = (abs(int(array_pred_rl[2]) - int(array_real_rl[2]))
  #print(round(mape_rl_0,2), round(mape_rl_1,2), round(mape_rl_2,2))
  
  
  #plt.plot(np.linspace(0,longitud*2,longitud*2),func_logistico2(np.linspace(0,longitud*2,longitud*2),*polinomios_logistico2[comunidad][0])-(miu - li),linewidth=4)
  #plt.plot(range(longitud),ccaadict[comunidad][timeserieschosen]["acumulado_contagios"],"o",color="red",markeredgewidth=3)
  #plt.legend(["Logistic Model", "Real Data"], prop={'size': 20})
  #plt.xlabel('DÍAS', fontsize=20)
  #plt.ylabel('CASOS', fontsize=20)
  #plt.xticks(fontsize=15)
  #plt.yticks(fontsize=15)
  
  #plt.savefig('figs/' + top5ccaa[a] + '.png')
  #plt.text(200, miu, r'$\mu=ls\ \sigma=15$', size=200)
  #v_text = "Ls: " + str('{:,}'.format(int(ls))) + " Li: " + str('{:,}'.format(int(li)))
  #plt.text(200, miu-0.1*miu, v_text, size=20)
  #plt.show()

mape_rl_t = ((abs(int(y_real_rl_0) - int(y_predic_rl_0)) + abs(int(y_real_rl_1) - int(y_predic_rl_1)) + abs(int(y_real_rl_2) - int(y_predic_rl_2))) / (int(y_real_rl_0)+int(y_real_rl_1)+int(y_real_rl_2)))*100
print('El mape del dataset de prueba para la regresión logística de las 5 ciudades :', round(mape_rl_t,2),"%")

"""Lo anterior representá una desviación mínima para la predición de los 3 últimos días a través de la regresión logística.

#Implementación HTML

Con el objetivo de compartir y desarrollar conocimiento a partir del proyecto realizado se organizó y presentó una visualización en html para que el cliente pueda ver los resultados del pronóstico de los dos modelos SIR y regresión logística. Cerrando así el ciclo presentado por la metodología presentada por CRISP-DM.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile index.html
# 
# <!DOCTYPE html>
# <html lang="en">
#   <head>
#     <meta charset="utf-8">
#       <title>Trabajo Final Analítica Predictiva - COVID-19 - TEAM AP-3</title>
#       <Style type = "text / css">
#         .wide-desplegable {
#         width: 200px;
#         }
#       </Style>
#   </head>
#   <body>
# 
#     <!--- Se resaltan los bordes de los bloques para realizar el diseño --->
# 
#     <header  style="border:1px solid white; border-width:2px;">
#        <font color="darkblue" face="Helvetica">
#        <center><h1>Trabajo Final Analítica Predictiva - COVID-19 - TEAM AP-3</h1>
#        </center>
#        </font>
#     </header>
# 
#     <nav style="border:1px solid white; border-width:2px;">
#         <font color="darkblue" face="Helvetica">
#         <h2>Modelo SIR</h2>
#       <h3><form name="link"><select id="ciudad" name="menu" onchange="selectPlot()"></h3>
#       <option value="file_sir_med.html">Medellín</option>
#       <option value="file_sir_bog.html">Bogotá</option>
#       <option value="file_sir_cal.html">Cali</option>
#       <option value="file_sir_car.html">Cartagena</option>
#       <option value="file_sir_bar.html">Barranquilla</option
#       </font>
#       </select>  <input onclick="location=document.link.menu.options[document.link.menu.selectedIndex].value;" type="button" value="Ver pronósticos" /><span style="line-height: 1.3em;"> </span></form>
#     </nav>
# 
#     <blockquote>
#     <blockquote>
#     <blockquote>
#     <div style="border:1px solid white; border-width:2px;">
#       <div class="myImage" id="file_sir_med.html"   style="display:block"> <img src="figs/SIR_ciudad_0.jpg"   alt="Medellin" width="1200" height="700">   </div>
#       <div class="myImage" id="file_sir_bog.html"   style="display:none">  <img src="figs/SIR_ciudad_1.jpg"   alt="Bogota" width="1200" height="700">   </div>
#       <div class="myImage" id="file_sir_cal.html"     style="display:none">  <img src="figs/SIR_ciudad_2.jpg"     alt="Cali" width="1200" height="700">     </div>
#       <div class="myImage" id="file_sir_car.html"   style="display:none">  <img src="figs/SIR_ciudad_3.jpg"   alt="Cartagena" width="1200" height="700">   </div>
#       <div class="myImage" id="file_sir_bar.html"  style="display:none">  <img src="figs/SIR_ciudad_4.jpg"  alt="Barranquilla" width="1200" height="700">  </div>
#     </div>
#     </blockquote>
#     </blockquote>
#     </blockquote>
# 
# 
#     <nav style="border:1px solid white; border-width:2px;">
#         <h2>Modelo Regresión Logistíca</h2>
#       <form name="link2"><select id="ciudad2" name="menu2" onchange="selectPlot2()">
#       <option value="file_rl_med.html">Medellín</option>
#       <option value="file_rl_bog.html">Bogotá</option>
#       <option value="file_rl_cal.html">Cali</option>
#       <option value="file_rl_car.html">Cartagena</option>
#       <option value="file_rl_bar.html">Barranquilla</option
#       </select>  <input onclick="location=document.link2.menu2.options[document.link2.menu2.selectedIndex].value;" type="button" value="Ver pronósticos" /><span style="line-height: 1.3em;"> </span></form>
#     </nav>
# 
#     <div style="border:1px solid white; border-width:2px;">
#       <div class="myImage2" id="file_rl_med.html"   style="display:block"> <img src="figs/Medellín.png"   alt="Medellin2" width="1500" height="750">   </div>
#       <div class="myImage2" id="file_rl_bog.html"   style="display:none">  <img src="figs/Bogota.png"   alt="Bogota2" width="1500" height="750">   </div>
#       <div class="myImage2" id="file_rl_cal.html"     style="display:none">  <img src="figs/Cali.png"     alt="Cali2" width="1500" height="750">     </div>
#       <div class="myImage2" id="file_rl_car.html"   style="display:none">  <img src="figs/Cartagena.png"   alt="Cartagena2" width="1500" height="750">   </div>
#       <div class="myImage2" id="file_rl_bar.html"  style="display:none">  <img src="figs/Barranquilla.png"  alt="Barranquilla2" width="1500" height="750">  </div>
#     </div>
# 
#     <script>
#       function selectPlot() {
#         var ciudad = document.getElementById("ciudad").value;
#         var images = document.getElementsByClassName("myImage");
#         for (var i = 0; i < images.length; i++) {
#           if (images[i].id == ciudad) {
#             images[i].style.display = "block"
#           }else{
#             images[i].style.display = "none"
#           }
#         }
#       }
#     </script>
# 
#     <script>
#       function selectPlot2() {
#         var ciudad2 = document.getElementById("ciudad2").value;
#         var images = document.getElementsByClassName("myImage2");
#         for (var i = 0; i < images.length; i++) {
#           if (images[i].id == ciudad2) {
#             images[i].style.display = "block"
#           }else{
#             images[i].style.display = "none"
#           }
#         }
#       }
#     </script>
#   </body>
# </html>

#Renombrar bogotá
import os
os.rename("/content/figs/Bogotá, D.C..png", "/content/figs/Bogota.png")

#Instalación de git
!apt install git

#Clonar repocitorio
!git config --global user.email 'sherreramo@unal.edu.co'
!git config --global user.name 'sherreramo'
from getpass import getpass
password = 'lddtetSIEMPRE1993'
!git clone https://sherreramo:$password@github.com/sherreramo/sherreramo.github.io
#%cd sherreramo.github.io

!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/index.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_sir_med.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_sir_bog.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_sir_cal.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_sir_car.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_sir_bar.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_rl_med.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_rl_bog.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_rl_cal.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_rl_car.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/file_rl_bar.html
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/SIR_ciudad_0.jpg
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/SIR_ciudad_1.jpg
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/SIR_ciudad_2.jpg
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/SIR_ciudad_3.jpg
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/SIR_ciudad_4.jpg
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/Medellín.png
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/Bogota.png
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/Cali.png
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/Cartagena.png
!rm /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/Barranquilla.png

# Commented out IPython magic to ensure Python compatibility.
# %cd sherreramo.github.io

!git add .

!git commit --message="Eliminar"

!git push origin master

# Commented out IPython magic to ensure Python compatibility.
# %ls

# Commented out IPython magic to ensure Python compatibility.
# %cd /content

!mv /content/index.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_sir_med.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_sir_bog.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_sir_cal.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_sir_car.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_sir_bar.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_rl_med.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_rl_bog.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_rl_cal.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_rl_car.html /content/sherreramo.github.io/Final_Analitica_Predictiva
!mv /content/file_rl_bar.html /content/sherreramo.github.io/Final_Analitica_Predictiva

# Commented out IPython magic to ensure Python compatibility.
# %cd figs

!mv /content/figs/SIR_ciudad_0.jpg /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/SIR_ciudad_1.jpg /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/SIR_ciudad_2.jpg /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/SIR_ciudad_3.jpg /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/SIR_ciudad_4.jpg /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/Medellín.png /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/Bogota.png /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/Cali.png /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/Cartagena.png /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/
!mv /content/figs/Barranquilla.png /content/sherreramo.github.io/Final_Analitica_Predictiva/figs/

# Commented out IPython magic to ensure Python compatibility.
# %cd ..

# Commented out IPython magic to ensure Python compatibility.
# %cd ..

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/

# Commented out IPython magic to ensure Python compatibility.
# %cd sherreramo.github.io

# Commented out IPython magic to ensure Python compatibility.
# %ls

!git add .

!git commit --message="Carga"

!git push origin master

"""#Dashboard

[Dash board](https://sherreramo.github.io/Final_Analitica_Predictiva/)

#Conclusiones

>- La Metodología CRISP - DM utilizada para el desarrollo del presente proyecto detalla claramente los pasos a seguir para la elaboración de cualquier tarea de Analítica, favoreciendo una mirada holistica a través de las diferentes fases, logrando así una mejor comprensión y estructura a la información trabajada.


>- Es imperativo resaltar la importancia que tiene dentro de cualquier metodología de trabajo en Analítica, la limpieza de datos para la construcción de Modelos, para identificar faltantes y errores en la información con el fin de mitigar desviaciones e inconsistencias que permitan converger en insight para solucionar problematicas de negocio y/o responder a preguntas de negocio que agregen valor. Con base en lo anterior se hizo necesario eliminar y reemplazar valores que permitieran lograr consistencia en la información, para la  consolidación de los datos necesarios y detallar las variables a incluir en los modelos.

>- El Modelo SIR desarrollado para la proyección de casos de COVID 19 se utilizó para las proyecciones a largo plazo mostrando consistencia en los resultados arrojados con MAPE aproximado de 40% , el modelo fue seleccionado por la experiencia que hay en su uso como modelador de pandemias, para la implementación fue importante hallar las tasas de contagio y las tasas de salida, la cual consolida las tasas de recuperación y fallecidos sobre los casos activos del día inmediatamente anterior.

>- El Modelo de Regresión Logística se diseño para hacer una descripción en el corto plazo del COVID – 19 ajustándose adecuadamente a la realidad y describiendo claramente el crecimiento exponencial característico de las pandemias. Es así que se logró evidenciar en un lapso de 10 días la evolución de la pandemia con buenos aciertos y a su vez poder identificar las fechas especificas para determinar el pico de contagios, logrando aportar información relevante para la toma de decisiones.

>- Ambos modelos se caracterizan por tener pros y contras. Por ejemplo, el modelo de regresión logística tiene una mejor acertividad en el corto plazo, en comparación al modelo SIR. Sin embargo, la represión logística no permite una buena modelación del fenómeno pandemico debido a la naturaleza de converger en su valor máximo. Mientras que el modelo SIR describe claramente el comportamiento habitual de dicho fenómeno.

>- Podemos decir entonces que los dos modelos creados para la predicción de casos, son coherentes con la realidad permitiendo inferir que para Colombia el mayor número de casos reportados corresponde a la ciudad de Bogotá y que a su vez será la ciudad que más se demoré en llegar a su pico de  casos considerando su gran población. A su vez, este tipo de información permite dar visibilidad a los entes de gobierno para establecer medidas de contingencia y/o disponer de recursos de capacidad de atención médica para hacer frente a la situación de salubridad.
"""